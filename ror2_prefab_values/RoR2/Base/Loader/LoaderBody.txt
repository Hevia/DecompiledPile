Key Path : RoR2/Base/Loader/LoaderBody.prefab | UnityObject Type : UnityEngine.GameObject | UnityObject Name : LoaderBody

> transform = p: (65.8, -140.5, -237.0) r: (0.0, 359.9, 0.0) s: (1.0, 1.0, 1.0)
> UnityEngine.Networking.NetworkIdentity
>v m_SceneId = 0
>v m_AssetId = d81216609fe333e40b24376845322cbc
>v m_ServerOnly = False
>v m_LocalPlayerAuthority = True
>v m_IsClient = False
>v m_IsServer = False
>v m_HasAuthority = False
>v m_NetId = 0
>v m_IsLocalPlayer = False
>v m_ConnectionToServer = 
>v m_ConnectionToClient = 
>v m_PlayerId = -1
>v m_NetworkBehaviours = 
>v m_ObserverConnections = 
>v m_Observers = 
>v m_ClientAuthorityOwner = 
>v m_Reset = False
>v s_NextNetworkId = 1
>v s_UpdateWriter = UnityEngine.Networking.NetworkWriter
>v clientAuthorityCallback = 
>v onNetworkIdAssigned = 
>v onStartServerGlobal = 
>v isClient = False
>v isServer = False
>v hasAuthority = False
>v netId = 0
>v sceneId = 0
>v serverOnly = False
>v localPlayerAuthority = True
>v clientAuthorityOwner = 
>v assetId = d81216609fe333e40b24376845322cbc
>v isLocalPlayer = False
>v playerControllerId = -1
>v connectionToServer = 
>v connectionToClient = 
>v observers = 

> RoR2.CharacterMotor
>v instancesList = System.Collections.Generic.List`1[RoR2.CharacterMotor]
>v walkSpeedPenaltyCoefficient = 1
>v characterDirection = 
>v muteWalkMotion = False
>v mass = 150
>v airControl = 0,25
>v disableAirControlUntilCollision = False
>v generateParametersOnAwake = True
>v networkIdentity = 
>v body = 
>v capsuleCollider = 
>v enableMotorWithoutAuthority = False
>v alive = True
>v restDuration = 1
>v restVelocityThreshold = 0,025
>v restVelocityThresholdSqr = 0,000625
>v slipStartAngle = 70
>v slipEndAngle = 55
>v restStopwatch = 0
>v previousPosition = (0.0, 0.0, 0.0)
>v isAirControlForced = False
>v jumpCount = 0
>v netIsGrounded = False
>v netGroundNormal = (0.0, 0.0, 0.0)
>v velocity = (0.0, 0.0, 0.0)
>v lastVelocity = (0.0, 0.0, 0.0)
>v rootMotion = (0.0, 0.0, 0.0)
>v _moveDirection = (0.0, 0.0, 0.0)
>v <lastGroundedTime>k__BackingField = RoR2.Run+FixedTimeStamp
>v cvCMotorSafeCollisionStepThreshold = RoR2.ConVar.FloatConVar
>v _safeCollisionEnableCount = 0
>v onHitGroundServer = 
>v onHitGroundAuthority = 
>v onMovementHit = 
>v _gravityParameters = RoR2.CharacterGravityParameters
>v <useGravity>k__BackingField = False
>v _flightParameters = RoR2.CharacterFlightParameters
>v <isFlying>k__BackingField = False
>v kRpcRpcApplyForceImpulse = 1042934326
>v kCmdCmdReportHitGround = 1796547162
>v atRest = False
>v hasEffectiveAuthority = False
>v estimatedGroundNormal = (0.0, 0.0, 0.0)
>v isGrounded = False
>v moveDirection = (0.0, 0.0, 0.0)
>v lastGroundedTime = RoR2.Run+FixedTimeStamp
>v gravityParameters = RoR2.CharacterGravityParameters
>v useGravity = False
>v flightParameters = RoR2.CharacterFlightParameters
>v isFlying = False

> RoR2.InputBankTest
>v characterBody = 
>v _aimDirection = (0.0, 0.0, 0.0)
>v lastRaycastTime = -Infini
>v lastFixedRaycastTime = -Infini
>v didLastRaycastHit = False
>v lastHitInfo = UnityEngine.RaycastHit
>v lastMaxDistance = 0
>v cachedRaycast = RoR2.InputBankTest+CachedRaycastInfo
>v moveVector = (0.0, 0.0, 0.0)
>v skill1 = RoR2.InputBankTest+ButtonState
>v skill2 = RoR2.InputBankTest+ButtonState
>v skill3 = RoR2.InputBankTest+ButtonState
>v skill4 = RoR2.InputBankTest+ButtonState
>v interact = RoR2.InputBankTest+ButtonState
>v jump = RoR2.InputBankTest+ButtonState
>v sprint = RoR2.InputBankTest+ButtonState
>v activateEquipment = RoR2.InputBankTest+ButtonState
>v ping = RoR2.InputBankTest+ButtonState
>v <emoteRequest>k__BackingField = -1
>v aimDirection = (0.0, 0.0, 1.0)
>v emoteRequest = -1

> RoR2.CharacterBody
>v bodyIndex = 70
>v baseNameToken = LOADER_BODY_NAME
>v subtitleNameToken = LOADER_BODY_SUBTITLE
>v activeBuffsList = 
>v activeBuffsListCount = 0
>v buffs = 
>v eliteBuffCount = 0
>v timedBuffs = System.Collections.Generic.List`1[RoR2.CharacterBody+TimedBuff]
>v pendingTonicAfflictionCount = 0
>v warCryEffectInstance = 
>v bodyFlags = IgnoreFallDamage, ImmuneToExecutes
>v masterObjectId = 0
>v _masterObject = 
>v _master = 
>v <inventory>k__BackingField = 
>v linkedToMaster = False
>v <isPlayerControlled>k__BackingField = False
>v disablingHurtBoxes = False
>v previousEquipmentIndex = None
>v <executeEliteHealthFraction>k__BackingField = 0
>v onInventoryChanged = 
>v transform = 
>v <rigidbody>k__BackingField = 
>v <networkIdentity>k__BackingField = 
>v <characterMotor>k__BackingField = 
>v <characterDirection>k__BackingField = 
>v <teamComponent>k__BackingField = 
>v <healthComponent>k__BackingField = 
>v <equipmentSlot>k__BackingField = 
>v <inputBank>k__BackingField = 
>v <skillLocator>k__BackingField = 
>v sfxLocator = 
>v <modelLocator>k__BackingField = 
>v <hurtBoxGroup>k__BackingField = 
>v <mainHurtBox>k__BackingField = 
>v <coreTransform>k__BackingField = 
>v onSkillActivatedServer = 
>v onSkillActivatedAuthority = 
>v instancesList = System.Collections.Generic.List`1[RoR2.CharacterBody]
>v readOnlyInstancesList = System.Collections.ObjectModel.ReadOnlyCollection`1[RoR2.CharacterBody]
>v onBodyAwakeGlobal = System.Action`1[RoR2.CharacterBody]
>v onBodyDestroyGlobal = System.Action`1[RoR2.CharacterBody]
>v onBodyStartGlobal = System.Action`1[RoR2.CharacterBody]
>v onBodyInventoryChangedGlobal = System.Action`1[RoR2.CharacterBody]
>v <hasEffectiveAuthority>k__BackingField = False
>v _isSprinting = False
>v outOfCombatDelay = 5
>v outOfDangerDelay = 7
>v outOfCombatStopwatch = 0
>v outOfDangerStopwatch = 0
>v <outOfCombat>k__BackingField = True
>v _outOfDanger = True
>v previousPosition = (0.0, 0.0, 0.0)
>v notMovingWait = 1
>v notMovingStopwatch = 0
>v rootMotionInMainState = False
>v mainRootSpeed = 0
>v baseMaxHealth = 160
>v baseRegen = 2,5
>v baseMaxShield = 0
>v baseMoveSpeed = 7
>v baseAcceleration = 80
>v baseJumpPower = 15
>v baseDamage = 12
>v baseAttackSpeed = 1
>v baseCrit = 1
>v baseArmor = 20
>v baseVisionDistance = +Infini
>v baseJumpCount = 1
>v sprintingSpeedMultiplier = 1,45
>v autoCalculateLevelStats = True
>v levelMaxHealth = 48
>v levelRegen = 0,5
>v levelMaxShield = 0
>v levelMoveSpeed = 0
>v levelJumpPower = 0
>v levelDamage = 2,4
>v levelAttackSpeed = 0
>v levelCrit = 0
>v levelArmor = 0
>v <experience>k__BackingField = 0
>v <level>k__BackingField = 0
>v <maxHealth>k__BackingField = 0
>v <maxBarrier>k__BackingField = 0
>v <barrierDecayRate>k__BackingField = 0
>v <regen>k__BackingField = 0
>v <maxShield>k__BackingField = 0
>v <moveSpeed>k__BackingField = 0
>v <acceleration>k__BackingField = 0
>v <jumpPower>k__BackingField = 0
>v <maxJumpCount>k__BackingField = 0
>v <maxJumpHeight>k__BackingField = 0
>v <damage>k__BackingField = 0
>v <attackSpeed>k__BackingField = 0
>v <crit>k__BackingField = 0
>v <critMultiplier>k__BackingField = 0
>v <bleedChance>k__BackingField = 0
>v <armor>k__BackingField = 0
>v <visionDistance>k__BackingField = 0
>v <critHeal>k__BackingField = 0
>v <cursePenalty>k__BackingField = 0
>v <hasOneShotProtection>k__BackingField = False
>v <isGlass>k__BackingField = False
>v <oneShotProtectionFraction>k__BackingField = 0
>v <canPerformBackstab>k__BackingField = False
>v <canReceiveBackstab>k__BackingField = False
>v statsDirty = False
>v aimTimer = 0
>v masterDirtyBit = 1
>v buffsDirtyBit = 2
>v outOfCombatBit = 4
>v outOfDangerBit = 8
>v sprintingBit = 16
>v allDirtyBits = 31
>v <killCountServer>k__BackingField = 0
>v helfireController = 
>v helfireLifetime = 0
>v fireTrail = 
>v wasLucky = False
>v poisonballAngle = 25
>v poisonballDamageCoefficient = 1
>v poisonballRefreshTime = 6
>v poisonballTimer = 0
>v lunarMissileDamageCoefficient = 0,3
>v lunarMissileRefreshTime = 10
>v lunarMissileDelayBetweenShots = 0,1
>v lunarMissileRechargeTimer = 10
>v lunarMissileTimerBetweenShots = 0
>v remainingMissilesToFire = 0
>v lunarMissilePrefab = 
>v timeBubbleWardInstance = 
>v engiShieldTempEffectInstance = 
>v bucklerShieldTempEffectInstance = 
>v slowDownTimeTempEffectInstance = 
>v crippleEffectInstance = 
>v tonicBuffEffectInstance = 
>v weakTempEffectInstance = 
>v energizedTempEffectInstance = 
>v barrierTempEffectInstance = 
>v nullifyStack1EffectInstance = 
>v nullifyStack2EffectInstance = 
>v nullifyStack3EffectInstance = 
>v regenBoostEffectInstance = 
>v elephantDefenseEffectInstance = 
>v healingDisabledEffectInstance = 
>v noCooldownEffectInstance = 
>v doppelgangerEffectInstance = 
>v deathmarkEffectInstance = 
>v crocoRegenEffectInstance = 
>v mercExposeEffectInstance = 
>v lifestealOnHitEffectInstance = 
>v teamWarCryEffectInstance = 
>v randomDamageEffectInstance = 
>v lunarGolemShieldEffectInstance = 
>v warbannerEffectInstance = 
>v teslaFieldEffectInstance = 
>v lunarSecondaryRootEffectInstance = 
>v lunarDetonatorEffectInstance = 
>v fruitingEffectInstance = 
>v mushroomVoidTempEffectInstance = 
>v bearVoidTempEffectInstance = 
>v outOfCombatArmorEffectInstance = 
>v voidFogMildEffectInstance = 
>v voidFogStrongEffectInstance = 
>v voidJailerSlowEffectInstance = 
>v voidRaidcrabWardWipeFogEffectInstance = 
>v spreadBloomDecayTime = 1
>v spreadBloomCurve = UnityEngine.AnimationCurve
>v spreadBloomInternal = 0
>v _defaultCrosshairPrefab = LoaderCrosshair (UnityEngine.GameObject)
>v hideCrosshair = False
>v multiKillMaxInterval = 1
>v multiKillTimer = 0
>v <multiKillCount>k__BackingField = 0
>v multiKillThresholdForWarcry = 4
>v <radius>k__BackingField = 0
>v aimOriginTransform = AimOrigin (UnityEngine.Transform)
>v hullClassification = Human
>v portraitIcon = LoaderBody (UnityEngine.Texture2D)
>v bodyColor = RGBA(0.404, 0.439, 0.871, 1.000)
>v isChampion = False
>v <isElite>k__BackingField = False
>v currentVehicle = 
>v preferredPodPrefab = SurvivorPod (UnityEngine.GameObject)
>v preferredInitialStateType = EntityStates.SerializableEntityStateType
>v skinIndex = 0
>v <localStartTime>k__BackingField = RoR2.Run+FixedTimeStamp
>v customKillTotalStatName = 
>v overrideCoreTransform = chest (UnityEngine.Transform)
>v kCmdCmdAddTimedBuff = -160178508
>v kCmdCmdUpdateSprint = -1006016914
>v kCmdCmdOnSkillActivated = 384138986
>v kRpcRpcBark = -76716871
>v kCmdCmdRequestVehicleEjection = 1803737791
>v kRpcRpcUsePreferredInitialStateType = 638695010
>v master = 
>v inventory = 
>v isPlayerControlled = False
>v executeEliteHealthFraction = 0
>v masterObject = 
>v rigidbody = 
>v networkIdentity = 
>v characterMotor = 
>v characterDirection = 
>v teamComponent = 
>v healthComponent = 
>v equipmentSlot = 
>v inputBank = 
>v skillLocator = 
>v modelLocator = 
>v hurtBoxGroup = 
>v mainHurtBox = 
>v coreTransform = 
>v hasEffectiveAuthority = False
>v isSprinting = False
>v outOfCombat = True
>v outOfDanger = True
>v experience = 0
>v level = 0
>v maxHealth = 0
>v maxBarrier = 0
>v barrierDecayRate = 0
>v regen = 0
>v maxShield = 0
>v moveSpeed = 0
>v acceleration = 0
>v jumpPower = 0
>v maxJumpCount = 0
>v maxJumpHeight = 0
>v damage = 0
>v attackSpeed = 0
>v crit = 0
>v critMultiplier = 0
>v bleedChance = 0
>v armor = 0
>v visionDistance = 0
>v critHeal = 0
>v cursePenalty = 0
>v hasOneShotProtection = False
>v isGlass = False
>v oneShotProtectionFraction = 0
>v canPerformBackstab = False
>v canReceiveBackstab = False
>v shouldAim = False
>v killCountServer = 0
>v bestFitRadius = 1
>v spreadBloomAngle = 0
>v defaultCrosshairPrefab = LoaderCrosshair (UnityEngine.GameObject)
>v multiKillCount = 0
>v radius = 0
>v aimOrigin = (65.8, -139.6, -237.0)
>v isElite = False
>v isBoss = False
>v isFlying = True
>v localStartTime = RoR2.Run+FixedTimeStamp
>v isEquipmentActivationAllowed = True

> RoR2.CameraTargetParams
>v cameraParams = ccpLoader (RoR2.CharacterCameraParams)
>v cameraPivotTransform = CameraPivot (UnityEngine.Transform)
>v fovOverride = 0
>v recoil = (0.0, 0.0)
>v dontRaycastToPivot = False
>v targetRecoilDampTime = 0,08
>v recoilDampTime = 0,05
>v targetRecoil = (0.0, 0.0)
>v recoilVelocity = (0.0, 0.0)
>v targetRecoilVelocity = (0.0, 0.0)
>v aimRequestStack = System.Collections.Generic.List`1[RoR2.CameraTargetParams+AimRequest]
>v easeCurve = UnityEngine.AnimationCurve
>v cameraParamsOverrides = 
>v _currentCameraParamsData = RoR2.CharacterCameraParamsData

> RoR2.ModelLocator
>v _modelTransform = mdlLoader (UnityEngine.Transform)
>v modelDestructionNotifier = 
>v modelBaseTransform = ModelBase (UnityEngine.Transform)
>v onModelChanged = 
>v autoUpdateModelTransform = True
>v dontDetatchFromParent = False
>v modelParentTransform = 
>v noCorpse = False
>v dontReleaseModelOnDeath = False
>v preserveModel = False
>v normalizeToFloor = False
>v normalSmoothdampTime = 0,1
>v normalMaxAngleDelta = 90
>v normalSmoothdampVelocity = (0.0, 0.0, 0.0)
>v targetNormal = (0.0, 1.0, 0.0)
>v currentNormal = (0.0, 1.0, 0.0)
>v characterMotor = 
>v modelTransform = mdlLoader (UnityEngine.Transform)

> RoR2.EntityStateMachine
>v <state>k__BackingField = 
>v nextState = 
>v customName = Body
>v initialStateType = EntityStates.SerializableEntityStateType
>v mainStateType = EntityStates.SerializableEntityStateType
>v <networker>k__BackingField = 
>v <networkIdentity>k__BackingField = 
>v commonComponents = RoR2.EntityStateMachine+CommonComponentCache
>v networkIndex = -1
>v nextStateModifier = 
>v <destroying>k__BackingField = False
>v state = 
>v networker = 
>v networkIdentity = 
>v destroying = False

> RoR2.EntityStateMachine
>v <state>k__BackingField = 
>v nextState = 
>v customName = Weapon
>v initialStateType = EntityStates.SerializableEntityStateType
>v mainStateType = EntityStates.SerializableEntityStateType
>v <networker>k__BackingField = 
>v <networkIdentity>k__BackingField = 
>v commonComponents = RoR2.EntityStateMachine+CommonComponentCache
>v networkIndex = -1
>v nextStateModifier = 
>v <destroying>k__BackingField = False
>v state = 
>v networker = 
>v networkIdentity = 
>v destroying = False

> RoR2.EntityStateMachine
>v <state>k__BackingField = 
>v nextState = 
>v customName = Hook
>v initialStateType = EntityStates.SerializableEntityStateType
>v mainStateType = EntityStates.SerializableEntityStateType
>v <networker>k__BackingField = 
>v <networkIdentity>k__BackingField = 
>v commonComponents = RoR2.EntityStateMachine+CommonComponentCache
>v networkIndex = -1
>v nextStateModifier = 
>v <destroying>k__BackingField = False
>v state = 
>v networker = 
>v networkIdentity = 
>v destroying = False

> RoR2.EntityStateMachine
>v <state>k__BackingField = 
>v nextState = 
>v customName = Pylon
>v initialStateType = EntityStates.SerializableEntityStateType
>v mainStateType = EntityStates.SerializableEntityStateType
>v <networker>k__BackingField = 
>v <networkIdentity>k__BackingField = 
>v commonComponents = RoR2.EntityStateMachine+CommonComponentCache
>v networkIndex = -1
>v nextStateModifier = 
>v <destroying>k__BackingField = False
>v state = 
>v networker = 
>v networkIdentity = 
>v destroying = False

> RoR2.CharacterDirection
>v moveVector = (0.0, 0.0, 0.0)
>v targetTransform = ModelBase (UnityEngine.Transform)
>v overrideAnimatorForwardTransform = ROOT (UnityEngine.Transform)
>v rootMotionAccumulator = 
>v modelAnimator = 
>v driveFromRootRotation = False
>v turnSpeed = 720
>v turnSoundName = 
>v previousParamsIndex = -1
>v yRotationVelocity = 0
>v _yaw = 0
>v targetVector = (0.0, 0.0, 0.0)
>v <hasEffectiveAuthority>k__BackingField = False
>v offset = 22,5
>v turnAnimatorParamsSets = RoR2.CharacterDirection+TurnAnimatorParamsSet[]
>v paramsMidIndex = 3
>v yaw = 0
>v animatorForward = (0.0, 0.0, 1.0)
>v forward = (0.0, 0.0, 1.0)
>v hasEffectiveAuthority = False

> RoR2.GenericSkill
>v <skillDef>k__BackingField = 
>v _skillFamily = LoaderBodyPrimaryFamily (RoR2.Skills.SkillFamily)
>v <baseSkill>k__BackingField = 
>v skillName = GroundLight
>v hideInCharacterSelect = False
>v <stateMachine>k__BackingField = 
>v <skillInstanceData>k__BackingField = 
>v <characterBody>k__BackingField = 
>v <defaultSkillDef>k__BackingField = 
>v onSkillChanged = 
>v stateMachineLookupBuffer = System.Collections.Generic.List`1[RoR2.EntityStateMachine]
>v skillOverrides = RoR2.GenericSkill+SkillOverride[]
>v bonusStockFromBody = 0
>v <maxStock>k__BackingField = 0
>v <stock>k__BackingField = 0
>v finalRechargeInterval = 0
>v _cooldownScale = 1
>v _flatCooldownReduction = 1
>v <rechargeStopwatch>k__BackingField = 0
>v hasExecutedSuccessfully = False
>v _customStateMachineResolver = 
>v skillDef = 
>v skillFamily = LoaderBodyPrimaryFamily (RoR2.Skills.SkillFamily)
>v baseSkill = 
>v stateMachine = 
>v skillInstanceData = 
>v characterBody = 
>v defaultSkillDef = 
>v maxStock = 0
>v stock = 0
>v cooldownScale = 1
>v flatCooldownReduction = 1
>v rechargeStopwatch = 0
>v cooldownRemaining = 0

> RoR2.GenericSkill
>v <skillDef>k__BackingField = 
>v _skillFamily = LoaderBodySecondaryFamily (RoR2.Skills.SkillFamily)
>v <baseSkill>k__BackingField = 
>v skillName = Whirlwind
>v hideInCharacterSelect = False
>v <stateMachine>k__BackingField = 
>v <skillInstanceData>k__BackingField = 
>v <characterBody>k__BackingField = 
>v <defaultSkillDef>k__BackingField = 
>v onSkillChanged = 
>v stateMachineLookupBuffer = System.Collections.Generic.List`1[RoR2.EntityStateMachine]
>v skillOverrides = RoR2.GenericSkill+SkillOverride[]
>v bonusStockFromBody = 0
>v <maxStock>k__BackingField = 0
>v <stock>k__BackingField = 0
>v finalRechargeInterval = 0
>v _cooldownScale = 1
>v _flatCooldownReduction = 1
>v <rechargeStopwatch>k__BackingField = 0
>v hasExecutedSuccessfully = False
>v _customStateMachineResolver = 
>v skillDef = 
>v skillFamily = LoaderBodySecondaryFamily (RoR2.Skills.SkillFamily)
>v baseSkill = 
>v stateMachine = 
>v skillInstanceData = 
>v characterBody = 
>v defaultSkillDef = 
>v maxStock = 0
>v stock = 0
>v cooldownScale = 1
>v flatCooldownReduction = 1
>v rechargeStopwatch = 0
>v cooldownRemaining = 0

> RoR2.GenericSkill
>v <skillDef>k__BackingField = 
>v _skillFamily = LoaderBodyUtilityFamily (RoR2.Skills.SkillFamily)
>v <baseSkill>k__BackingField = 
>v skillName = Dash
>v hideInCharacterSelect = False
>v <stateMachine>k__BackingField = 
>v <skillInstanceData>k__BackingField = 
>v <characterBody>k__BackingField = 
>v <defaultSkillDef>k__BackingField = 
>v onSkillChanged = 
>v stateMachineLookupBuffer = System.Collections.Generic.List`1[RoR2.EntityStateMachine]
>v skillOverrides = RoR2.GenericSkill+SkillOverride[]
>v bonusStockFromBody = 0
>v <maxStock>k__BackingField = 0
>v <stock>k__BackingField = 0
>v finalRechargeInterval = 0
>v _cooldownScale = 1
>v _flatCooldownReduction = 1
>v <rechargeStopwatch>k__BackingField = 0
>v hasExecutedSuccessfully = False
>v _customStateMachineResolver = 
>v skillDef = 
>v skillFamily = LoaderBodyUtilityFamily (RoR2.Skills.SkillFamily)
>v baseSkill = 
>v stateMachine = 
>v skillInstanceData = 
>v characterBody = 
>v defaultSkillDef = 
>v maxStock = 0
>v stock = 0
>v cooldownScale = 1
>v flatCooldownReduction = 1
>v rechargeStopwatch = 0
>v cooldownRemaining = 0

> RoR2.GenericSkill
>v <skillDef>k__BackingField = 
>v _skillFamily = LoaderBodySpecialFamily (RoR2.Skills.SkillFamily)
>v <baseSkill>k__BackingField = 
>v skillName = Evis
>v hideInCharacterSelect = False
>v <stateMachine>k__BackingField = 
>v <skillInstanceData>k__BackingField = 
>v <characterBody>k__BackingField = 
>v <defaultSkillDef>k__BackingField = 
>v onSkillChanged = 
>v stateMachineLookupBuffer = System.Collections.Generic.List`1[RoR2.EntityStateMachine]
>v skillOverrides = RoR2.GenericSkill+SkillOverride[]
>v bonusStockFromBody = 0
>v <maxStock>k__BackingField = 0
>v <stock>k__BackingField = 0
>v finalRechargeInterval = 0
>v _cooldownScale = 1
>v _flatCooldownReduction = 1
>v <rechargeStopwatch>k__BackingField = 0
>v hasExecutedSuccessfully = False
>v _customStateMachineResolver = 
>v skillDef = 
>v skillFamily = LoaderBodySpecialFamily (RoR2.Skills.SkillFamily)
>v baseSkill = 
>v stateMachine = 
>v skillInstanceData = 
>v characterBody = 
>v defaultSkillDef = 
>v maxStock = 0
>v stock = 0
>v cooldownScale = 1
>v flatCooldownReduction = 1
>v rechargeStopwatch = 0
>v cooldownRemaining = 0

> RoR2.SkillLocator
>v primary = LoaderBody (RoR2.GenericSkill)
>v secondary = LoaderBody (RoR2.GenericSkill)
>v utility = LoaderBody (RoR2.GenericSkill)
>v special = LoaderBody (RoR2.GenericSkill)
>v passiveSkill = RoR2.SkillLocator+PassiveSkill
>v networkIdentity = 
>v allSkills = 
>v hasEffectiveAuthority = False
>v skillDefDirtyFlags = 0
>v inDeserialize = False
>v kRpcRpcDeductCooldownFromAllSkillsServer = -2090076365

> RoR2.TeamComponent
>v hideAllyCardDisplay = False
>v _teamIndex = None
>v <body>k__BackingField = 
>v oldTeamIndex = None
>v defaultIndicatorPrefab = 
>v indicator = 
>v indicatorSetupQueue = System.Collections.Generic.Queue`1[RoR2.TeamComponent]
>v teamsList = System.Collections.Generic.List`1[RoR2.TeamComponent][]
>v readonlyTeamsList = System.Collections.ObjectModel.ReadOnlyCollection`1[RoR2.TeamComponent][]
>v emptyTeamMembers = System.Collections.ObjectModel.ReadOnlyCollection`1[RoR2.TeamComponent]
>v onJoinTeamGlobal = 
>v onLeaveTeamGlobal = 
>v body = 
>v teamIndex = None

> RoR2.HealthComponent
>v lowHealthFraction = 0,25
>v health = 100
>v shield = 0
>v barrier = 0
>v magnetiCharge = 0
>v dontShowHealthbar = False
>v globalDeathEventChanceCoefficient = 1
>v _killingDamageType = 0
>v body = 
>v modelLocator = 
>v painAnimationHandler = 
>v onIncomingDamageReceivers = 
>v onTakeDamageReceivers = 
>v <lastHitTime>k__BackingField = RoR2.Run+FixedTimeStamp
>v <lastHealTime>k__BackingField = RoR2.Run+FixedTimeStamp
>v <lastHitAttacker>k__BackingField = 
>v <godMode>k__BackingField = False
>v <potionReserve>k__BackingField = 0
>v <isInFrozenState>k__BackingField = False
>v frozenExecuteThreshold = 0,3
>v adaptiveArmorPerOnePercentTaken = 30
>v adaptiveArmorDecayPerSecond = 40
>v adaptiveArmorCap = 400
>v medkitActivationDelay = 2
>v devilOrbMaxTimer = 0,1
>v devilOrbHealPool = 0
>v devilOrbTimer = 0
>v regenAccumulator = 0
>v wasAlive = True
>v adaptiveArmorValue = 0
>v isShieldRegenForced = False
>v onCharacterHealServer = System.Action`3[RoR2.HealthComponent,System.Single,RoR2.ProcChainMask]
>v ospTimer = 0
>v ospBufferDuration = 0,1
>v serverDamageTakenThisUpdate = 0
>v repeatHealComponent = 
>v itemCounts = RoR2.HealthComponent+ItemCounts
>v currentEquipmentIndex = 0
>v kCmdCmdHealFull = -290141736
>v kCmdCmdRechargeShieldFull = -833942624
>v kCmdCmdAddBarrier = -1976809257
>v kCmdCmdForceShieldRegen = -1029271894
>v killingDamageType = Generic
>v alive = True
>v combinedHealth = 100
>v lastHitTime = RoR2.Run+FixedTimeStamp
>v lastHealTime = RoR2.Run+FixedTimeStamp
>v lastHitAttacker = 
>v timeSinceLastHit = 0
>v timeSinceLastHeal = 0
>v godMode = False
>v potionReserve = 0
>v isInFrozenState = False
>v Networkhealth = 100
>v Networkshield = 0
>v Networkbarrier = 0
>v NetworkmagnetiCharge = 0
>v Network_killingDamageType = 0

> RoR2.Interactor
>v maxInteractionDistance = 3
>v kCmdCmdInteract = 591229007
>v kRpcRpcInteractionResult = 804118976

> RoR2.InteractionDriver
>v highlightInteractor = True
>v inputReceived = False
>v networkIdentity = 
>v <interactor>k__BackingField = 
>v inputBank = 
>v characterBody = 
>v equipmentSlot = 
>v interactableOverride = 
>v interactableCooldownDuration = 0,25
>v interactableCooldown = 0
>v interactor = 

> RoR2.CharacterDeathBehavior
>v deathStateMachine = LoaderBody (RoR2.EntityStateMachine)
>v deathState = EntityStates.SerializableEntityStateType
>v idleStateMachine = RoR2.EntityStateMachine[]

> RoR2.Networking.CharacterNetworkTransform
>v instancesList = System.Collections.Generic.List`1[RoR2.Networking.CharacterNetworkTransform]
>v _readOnlyInstancesList = System.Collections.ObjectModel.ReadOnlyCollection`1[RoR2.Networking.CharacterNetworkTransform]
>v <transform>k__BackingField = 
>v <inputBank>k__BackingField = 
>v <characterMotor>k__BackingField = 
>v <characterDirection>k__BackingField = 
>v <rigidbody>k__BackingField = 
>v positionTransmitInterval = 0,05
>v lastPositionTransmitTime = -Infini
>v interpolationFactor = 3
>v newestNetSnapshot = RoR2.Networking.CharacterNetworkTransform+Snapshot
>v snapshots = System.Collections.Generic.List`1[RoR2.Networking.CharacterNetworkTransform+Snapshot]
>v debugDuplicatePositions = False
>v debugSnapshotReceived = False
>v rigidbodyStartedKinematic = True
>v <hasEffectiveAuthority>k__BackingField = False
>v readOnlyInstancesList = System.Collections.ObjectModel.ReadOnlyCollection`1[RoR2.Networking.CharacterNetworkTransform]
>v transform = 
>v inputBank = 
>v characterMotor = 
>v characterDirection = 
>v interpolationDelay = 0,15
>v hasEffectiveAuthority = False

> RoR2.NetworkStateMachine
>v stateMachines = RoR2.EntityStateMachine[]
>v networkIdentity = 

> RoR2.CharacterEmoteDefinitions
>v emoteDefinitions = RoR2.CharacterEmoteDefinitions+EmoteDef[]

> RoR2.EquipmentSlot
>v inventory = 
>v <activeEquipmentSlot>k__BackingField = 0
>v <equipmentIndex>k__BackingField = 0
>v <stock>k__BackingField = 0
>v <maxStock>k__BackingField = 0
>v _rechargeTime = RoR2.Run+FixedTimeStamp
>v hasEffectiveAuthority = False
>v rng = 
>v <characterBody>k__BackingField = 
>v healthComponent = 
>v inputBank = 
>v teamComponent = 
>v fullCritDuration = 8
>v tonicBuffDuration = 20
>v equipmentActivateString = Play_UI_equipment_activate
>v missileTimer = 0
>v bfgChargeTimer = 0
>v subcooldownTimer = 0
>v missileInterval = 0,125
>v remainingMissiles = 0
>v passiveHealingFollower = 
>v goldgatControllerObject = 
>v onServerEquipmentActivated = System.Action`2[RoR2.EquipmentSlot,RoR2.EquipmentIndex]
>v targetIndicator = 
>v targetFinder = RoR2.BullseyeSearch
>v currentTarget = RoR2.EquipmentSlot+UserTargetInfo
>v pickupSearch = 
>v kRpcRpcOnClientEquipmentActivationRecieved = 1342577121
>v kCmdCmdExecuteIfReady = -303452611
>v kCmdCmdOnEquipmentExecuted = 1725820338
>v activeEquipmentSlot = 0
>v equipmentIndex = 0
>v stock = 0
>v maxStock = 0
>v characterBody = 
>v cooldownTimer = 0

> RoR2.SfxLocator
>v deathSound = Play_ui_player_death
>v barkSound = 
>v openSound = 
>v landingSound = Play_char_land
>v fallDamageSound = Play_char_land_fall_damage
>v aliveLoopStart = 
>v aliveLoopStop = 
>v sprintLoopStart = 
>v sprintLoopStop = 

> RoR2.BodyAnimatorSmoothingParameters
>v smoothingParameters = RoR2.BodyAnimatorSmoothingParameters+SmoothingParameters
>v defaultParameters = RoR2.BodyAnimatorSmoothingParameters+SmoothingParameters

> UnityEngine.Rigidbody
>v velocity = (0.0, 0.0, 0.0)
>v angularVelocity = (0.0, 0.0, 0.0)
>v drag = 0
>v angularDrag = 0
>v mass = 150
>v useGravity = False
>v maxDepenetrationVelocity = 1E+32
>v isKinematic = True
>v freezeRotation = False
>v constraints = None
>v collisionDetectionMode = Discrete
>v centerOfMass = (0.0, 0.0, 0.0)
>v worldCenterOfMass = (0.0, 0.0, 0.0)
>v inertiaTensorRotation = (0.0, 0.0, 0.0, 1.0)
>v inertiaTensor = (1.0, 1.0, 1.0)
>v detectCollisions = True
>v position = (0.0, 0.0, 0.0)
>v rotation = (0.0, 0.0, 0.0, 1.0)
>v interpolation = None
>v solverIterations = 6
>v sleepThreshold = 0,005
>v maxAngularVelocity = 7
>v solverVelocityIterations = 1
>v sleepVelocity = 0
>v sleepAngularVelocity = 0
>v useConeFriction = False
>v solverIterationCount = 6
>v solverVelocityIterationCount = 1

> UnityEngine.CapsuleCollider
>v center = (0.0, 0.0, 0.0)
>v radius = 0,75
>v height = 1,82
>v direction = 1

> KinematicCharacterController.KinematicCharacterMotor
>v CharacterController = LoaderBody (RoR2.CharacterMotor)
>v Capsule = LoaderBody (UnityEngine.CapsuleCollider)
>v Rigidbody = LoaderBody (UnityEngine.Rigidbody)
>v CapsuleRadius = 0,75
>v CapsuleHeight = 1,82
>v CapsuleYOffset = 0
>v CapsulePhysicsMaterial = 
>v DetectDiscreteCollisions = False
>v GroundDetectionExtraDistance = 0
>v MaxStepHeight = 0,2
>v MinRequiredStepDepth = 0,1
>v MaxStableSlopeAngle = 55
>v MaxStableDistanceFromLedge = 0,5
>v PreventSnappingOnLedges = False
>v MaxStableDenivelationAngle = 55
>v RigidbodyInteractionType = None
>v PreserveAttachedRigidbodyMomentum = True
>v HasPlanarConstraint = False
>v PlanarConstraintAxis = (0.0, 0.0, 1.0)
>v StepHandling = Standard
>v LedgeHandling = True
>v InteractiveRigidbodyHandling = True
>v SafeMovement = False
>v GroundingStatus = KinematicCharacterController.CharacterGroundingReport
>v LastGroundingStatus = KinematicCharacterController.CharacterTransientGroundingReport
>v CollidableLayers = UnityEngine.LayerMask
>v <Transform>k__BackingField = 
>v <CharacterUp>k__BackingField = (0.0, 0.0, 0.0)
>v <CharacterForward>k__BackingField = (0.0, 0.0, 0.0)
>v <CharacterRight>k__BackingField = (0.0, 0.0, 0.0)
>v <InitialSimulationPosition>k__BackingField = (0.0, 0.0, 0.0)
>v <InitialSimulationRotation>k__BackingField = (0.0, 0.0, 0.0, 0.0)
>v <AttachedRigidbody>k__BackingField = 
>v <CharacterTransformToCapsuleCenter>k__BackingField = (0.0, 0.0, 0.0)
>v <CharacterTransformToCapsuleBottom>k__BackingField = (0.0, 0.0, 0.0)
>v <CharacterTransformToCapsuleTop>k__BackingField = (0.0, 0.0, 0.0)
>v <CharacterTransformToCapsuleBottomHemi>k__BackingField = (0.0, 0.0, 0.0)
>v <CharacterTransformToCapsuleTopHemi>k__BackingField = (0.0, 0.0, 0.0)
>v <MustUnground>k__BackingField = False
>v <LastMovementIterationFoundAnyGround>k__BackingField = False
>v <IndexInCharacterSystem>k__BackingField = 0
>v <InitialTickPosition>k__BackingField = (0.0, 0.0, 0.0)
>v <InitialTickRotation>k__BackingField = (0.0, 0.0, 0.0, 0.0)
>v <AttachedRigidbodyOverride>k__BackingField = 
>v _internalCharacterHits = UnityEngine.RaycastHit[]
>v _internalProbedColliders = UnityEngine.Collider[]
>v _rigidbodiesPushedThisMove = UnityEngine.Rigidbody[]
>v _internalRigidbodyProjectionHits = KinematicCharacterController.RigidbodyProjectionHit[]
>v _lastAttachedRigidbody = 
>v _solveMovementCollisions = True
>v _solveGrounding = True
>v _movePositionDirty = False
>v _movePositionTarget = (0.0, 0.0, 0.0)
>v _moveRotationDirty = False
>v _moveRotationTarget = (0.0, 0.0, 0.0, 1.0)
>v _lastSolvedOverlapNormalDirty = False
>v _lastSolvedOverlapNormal = (0.0, 0.0, 1.0)
>v _rigidbodiesPushedCount = 0
>v _rigidbodyProjectionHitCount = 0
>v _internalResultingMovementMagnitude = 0
>v _internalResultingMovementDirection = (0.0, 0.0, 0.0)
>v _isMovingFromAttachedRigidbody = False
>v _cachedWorldUp = (0.0, 1.0, 0.0)
>v _cachedWorldForward = (0.0, 0.0, 1.0)
>v _cachedWorldRight = (1.0, 0.0, 0.0)
>v _cachedZeroVector = (0.0, 0.0, 0.0)
>v _internalTransientPosition = (0.0, 0.0, 0.0)
>v _internalTransientRotation = (0.0, 0.0, 0.0, 0.0)
>v _baseVelocity = (0.0, 0.0, 0.0)
>v _attachedRigidbodyVelocity = (0.0, 0.0, 0.0)
>v <OverlapsCount>k__BackingField = 0
>v _overlaps = KinematicCharacterController.OverlapResult[]
>v MaxHitsBudget = 16
>v MaxCollisionBudget = 16
>v MaxGroundingSweepIterations = 2
>v MaxMovementSweepIterations = 6
>v MaxSteppingSweepIterations = 3
>v MaxRigidbodyOverlapsCount = 16
>v MaxDiscreteCollisionIterations = 3
>v CollisionOffset = 0,001
>v GroundProbeReboundDistance = 0,02
>v MinimumGroundProbingDistance = 0,005
>v GroundProbingBackstepDistance = 0,1
>v SweepProbingBackstepDistance = 0,002
>v SecondaryProbesVertical = 0,02
>v SecondaryProbesHorizontal = 0,001
>v MinVelocityMagnitude = 0,01
>v SteppingForwardDistance = 0,03
>v MinDistanceForLedge = 0,05
>v CorrelationForVerticalObstruction = 0,01
>v ExtraSteppingForwardDistance = 0,01
>v ExtraStepHeightPadding = 0,01
>v Transform = 
>v CharacterUp = (0.0, 0.0, 0.0)
>v CharacterForward = (0.0, 0.0, 0.0)
>v CharacterRight = (0.0, 0.0, 0.0)
>v InitialSimulationPosition = (0.0, 0.0, 0.0)
>v InitialSimulationRotation = (0.0, 0.0, 0.0, 0.0)
>v AttachedRigidbody = 
>v CharacterTransformToCapsuleCenter = (0.0, 0.0, 0.0)
>v CharacterTransformToCapsuleBottom = (0.0, 0.0, 0.0)
>v CharacterTransformToCapsuleTop = (0.0, 0.0, 0.0)
>v CharacterTransformToCapsuleBottomHemi = (0.0, 0.0, 0.0)
>v CharacterTransformToCapsuleTopHemi = (0.0, 0.0, 0.0)
>v MustUnground = False
>v LastMovementIterationFoundAnyGround = False
>v IndexInCharacterSystem = 0
>v InitialTickPosition = (0.0, 0.0, 0.0)
>v InitialTickRotation = (0.0, 0.0, 0.0, 0.0)
>v AttachedRigidbodyOverride = 
>v TransientPosition = (0.0, 0.0, 0.0)
>v TransientRotation = (0.0, 0.0, 0.0, 0.0)
>v Velocity = (0.0, 0.0, 0.0)
>v BaseVelocity = (0.0, 0.0, 0.0)
>v AttachedRigidbodyVelocity = (0.0, 0.0, 0.0)
>v OverlapsCount = 0
>v Overlaps = KinematicCharacterController.OverlapResult[]

> RoR2.SetStateOnHurt
>v hitThreshold = 5
>v targetStateMachine = LoaderBody (RoR2.EntityStateMachine)
>v idleStateMachine = RoR2.EntityStateMachine[]
>v hurtState = EntityStates.SerializableEntityStateType
>v canBeHitStunned = False
>v canBeStunned = False
>v canBeFrozen = True
>v hasEffectiveAuthority = True
>v stunChanceOnHitBaseChancePercent = 5
>v kRpcRpcSetStun = 788834249
>v kRpcRpcSetFrozen = 1781279215
>v kRpcRpcSetShock = -1316305549
>v kRpcRpcSetPain = 788726245
>v kRpcRpcCleanse = -339360280

>GameObject Children 0 ModelBase

>> transform = p: (0.0, -0.9, 0.0) r: (0.0, 359.9, 0.0) s: (1.0, 1.0, 1.0)
>>GameObject Children 0 mdlLoader

>>> transform = p: (0.0, 0.0, 0.0) r: (0.0, 359.9, 0.0) s: (1.2, 1.2, 1.2)
>>> UnityEngine.Animator
>>>v isOptimizable = True
>>>v isHuman = False
>>>v hasRootMotion = False
>>>v humanScale = 1
>>>v isInitialized = False
>>>v deltaPosition = (0.0, 0.0, 0.0)
>>>v deltaRotation = (0.0, 0.0, 0.0, 1.0)
>>>v velocity = (0.0, 0.0, 0.0)
>>>v angularVelocity = (0.0, 0.0, 0.0)
>>>v rootPosition = (0.0, 0.0, 0.0)
>>>v rootRotation = (0.0, 0.0, 0.0, 1.0)
>>>v applyRootMotion = False
>>>v linearVelocityBlending = False
>>>v animatePhysics = False
>>>v updateMode = Normal
>>>v hasTransformHierarchy = True
>>>v gravityWeight = 0
>>>v bodyPosition = (0.0, 0.0, 0.0)
>>>v bodyRotation = (0.0, 0.0, 0.0, 0.0)
>>>v stabilizeFeet = False
>>>v layerCount = 0
>>>v parameters = UnityEngine.AnimatorControllerParameter[]
>>>v parameterCount = 0
>>>v feetPivotActive = 0
>>>v pivotWeight = 0
>>>v pivotPosition = (0.0, 0.0, 0.0)
>>>v isMatchingTarget = False
>>>v speed = 1
>>>v targetPosition = (0.0, 0.0, 0.0)
>>>v targetRotation = (0.0, 0.0, 0.0, 1.0)
>>>v cullingMode = CullUpdateTransforms
>>>v playbackTime = -1
>>>v recorderStartTime = -1
>>>v recorderStopTime = -1
>>>v recorderMode = Offline
>>>v runtimeAnimatorController = animLoader (UnityEngine.AnimatorController)
>>>v hasBoundPlayables = False
>>>v avatar = mdlLoaderAvatar (UnityEngine.Avatar)
>>>v playableGraph = UnityEngine.Playables.PlayableGraph
>>>v layersAffectMassCenter = False
>>>v leftFeetBottomHeight = 0
>>>v rightFeetBottomHeight = 0
>>>v logWarnings = True
>>>v fireEvents = True
>>>v keepAnimatorControllerStateOnDisable = False

>>> RoR2.AimAnimator
>>>v inputBank = LoaderBody (RoR2.InputBankTest)
>>>v directionComponent = LoaderBody (RoR2.CharacterDirection)
>>>v pitchRangeMin = -45
>>>v pitchRangeMax = 45
>>>v yawRangeMin = -55
>>>v yawRangeMax = 55
>>>v pitchGiveupRange = 40
>>>v yawGiveupRange = 40
>>>v giveupDuration = 3
>>>v raisedApproachSpeed = 360
>>>v loweredApproachSpeed = 240
>>>v smoothTime = 0,15
>>>v fullYaw = False
>>>v aimType = Direct
>>>v enableAimWeight = False
>>>v <isOutsideOfRange>k__BackingField = False
>>>v UseTransformedAimVector = False
>>>v animatorComponent = 
>>>v pitchClipCycleEnd = 0
>>>v yawClipCycleEnd = 0
>>>v giveupTimer = 0
>>>v localAnglesToAimVector = RoR2.AimAnimator+AimAngles
>>>v overshootAngles = RoR2.AimAnimator+AimAngles
>>>v clampedLocalAnglesToAimVector = RoR2.AimAnimator+AimAngles
>>>v currentLocalAngles = RoR2.AimAnimator+AimAngles
>>>v smoothingVelocity = RoR2.AimAnimator+AimAngles
>>>v directionOverrideRequests = System.Collections.Generic.List`1[RoR2.AimAnimator+DirectionOverrideRequest]
>>>v aimPitchCycleHash = 2063086823
>>>v aimYawCycleHash = -1125570030
>>>v aimWeightHash = 964159016
>>>v isOutsideOfRange = False

>>> RoR2.CharacterModel
>>>v body = LoaderBody (RoR2.CharacterBody)
>>>v itemDisplayRuleSet = idrsLoader (RoR2.ItemDisplayRuleSet)
>>>v autoPopulateLightInfos = True
>>>v baseRendererInfos = RoR2.CharacterModel+RendererInfo[]
>>>v baseLightInfos = RoR2.CharacterModel+LightInfo[]
>>>v childLocator = 
>>>v goldAffixEffect = 
>>>v hurtBoxInfos = RoR2.CharacterModel+HurtBoxInfo[]
>>>v coreTransform = 
>>>v hitFlashBaseColor = RGBA(0.757, 0.424, 0.200, 1.000)
>>>v hitFlashShieldColor = RGBA(0.518, 0.624, 1.000, 1.000)
>>>v healFlashColor = RGBA(0.408, 0.769, 0.192, 1.000)
>>>v hitFlashDuration = 0,15
>>>v healFlashDuration = 0,35
>>>v _visibility = Visible
>>>v _isGhost = False
>>>v _isDoppelganger = False
>>>v _isEcho = False
>>>v invisibilityCount = 0
>>>v temporaryOverlays = System.Collections.Generic.List`1[RoR2.TemporaryOverlay]
>>>v materialsDirty = True
>>>v propertyStorage = 
>>>v inventoryEquipmentIndex = None
>>>v myEliteIndex = None
>>>v fade = 1
>>>v firstPersonFade = 1
>>>v mainSkinnedMeshRenderer = 
>>>v poisonEliteLightColor = RGBA(0.353, 1.000, 0.757, 0.800)
>>>v hauntedEliteLightColor = RGBA(0.596, 0.894, 0.851, 0.800)
>>>v lunarEliteLightColor = RGBA(1.000, 1.000, 1.000, 0.498)
>>>v voidEliteLightColor = RGBA(0.592, 0.306, 0.518, 0.800)
>>>v lightColorOverride = 
>>>v particleMaterialOverride = 
>>>v poisonAffixEffect = 
>>>v hauntedAffixEffect = 
>>>v voidAffixEffect = 
>>>v affixHauntedCloakLockoutDuration = 3
>>>v currentEquipmentDisplayIndex = None
>>>v enabledItemDisplays = 
>>>v parentedPrefabDisplays = System.Collections.Generic.List`1[RoR2.CharacterModel+ParentedPrefabDisplay]
>>>v limbMaskDisplays = System.Collections.Generic.List`1[RoR2.CharacterModel+LimbMaskDisplay]
>>>v limbFlagSet = RoR2.CharacterModel+LimbFlagSet
>>>v revealedMaterial = matRevealedEffect (UnityEngine.Material)
>>>v cloakedMaterial = matCloakedEffect (UnityEngine.Material)
>>>v ghostMaterial = matGhostEffect (UnityEngine.Material)
>>>v bellBuffMaterial = matBellBuff (UnityEngine.Material)
>>>v wolfhatMaterial = matWolfhatOverlay (UnityEngine.Material)
>>>v energyShieldMaterial = matEnergyShield (UnityEngine.Material)
>>>v fullCritMaterial = matFullCrit (UnityEngine.Material)
>>>v beetleJuiceMaterial = matBeetleJuice (UnityEngine.Material)
>>>v brittleMaterial = matBrittle (UnityEngine.Material)
>>>v clayGooMaterial = matClayGooDebuff (UnityEngine.Material)
>>>v slow80Material = matSlow80Debuff (UnityEngine.Material)
>>>v immuneMaterial = matImmune (UnityEngine.Material)
>>>v elitePoisonOverlayMaterial = matElitePoisonOverlay (UnityEngine.Material)
>>>v elitePoisonParticleReplacementMaterial = matElitePoisonParticleReplacement (UnityEngine.Material)
>>>v eliteHauntedOverlayMaterial = matEliteHauntedOverlay (UnityEngine.Material)
>>>v eliteJustHauntedOverlayMaterial = matEliteJustHauntedOverlay (UnityEngine.Material)
>>>v eliteHauntedParticleReplacementMaterial = matEliteHauntedParticleReplacement (UnityEngine.Material)
>>>v eliteLunarParticleReplacementMaterial = matEliteLunarParticleReplacement (UnityEngine.Material)
>>>v eliteVoidParticleReplacementMaterial = matEliteVoidParticleReplacement (UnityEngine.Material)
>>>v eliteVoidOverlayMaterial = matEliteVoidOverlay (UnityEngine.Material)
>>>v weakMaterial = matWeakOverlay (UnityEngine.Material)
>>>v pulverizedMaterial = matPulverizedOverlay (UnityEngine.Material)
>>>v doppelgangerMaterial = matDoppelganger (UnityEngine.Material)
>>>v ghostParticleReplacementMaterial = matGhostParticleReplacement (UnityEngine.Material)
>>>v lunarGolemShieldMaterial = matLunarGolemShield (UnityEngine.Material)
>>>v echoMaterial = matEcho (UnityEngine.Material)
>>>v gummyCloneMaterial = matGummyClone (UnityEngine.Material)
>>>v voidSurvivorCorruptMaterial = matVoidSurvivorCorruptOverlay (UnityEngine.Material)
>>>v voidShieldMaterial = matEnergyShieldVoid (UnityEngine.Material)
>>>v maxOverlays = 6
>>>v currentOverlays = UnityEngine.Material[]
>>>v activeOverlayCount = 0
>>>v wasPreviouslyClayGooed = False
>>>v wasPreviouslyHaunted = False
>>>v rtpcEliteEnemy = RoR2.WwiseUtils.RtpcSetter
>>>v shaderEliteRampIndex = -1
>>>v sharedMaterialArrays = UnityEngine.Material[][]
>>>v maxMaterials = 7
>>>v visibility = Visible
>>>v isGhost = False
>>>v isDoppelganger = False
>>>v isEcho = False

>>> RoR2.HitBoxGroup
>>>v groupName = Punch
>>>v hitBoxes = RoR2.HitBox[]

>>> RoR2.RagdollController
>>>v bones = UnityEngine.Transform[]
>>>v componentsToDisableOnRagdoll = UnityEngine.MonoBehaviour[]
>>>v animator = 

>>> RoR2.FootstepHandler
>>>v baseFootstepString = Play_loader_step
>>>v baseFootliftString = 
>>>v sprintFootstepOverrideString = Play_loader_step_sprint
>>>v sprintFootliftOverrideString = 
>>>v enableFootstepDust = False
>>>v footstepDustPrefab = 
>>>v childLocator = 
>>>v bodyInventory = 
>>>v animator = 
>>>v footstepDustInstanceTransform = 
>>>v footstepDustInstanceParticleSystem = 
>>>v footstepDustInstanceShakeEmitter = 
>>>v body = 

>>> RoR2.HurtBoxGroup
>>>v hurtBoxes = RoR2.HurtBox[]
>>>v mainHurtBox = TempHurtbox (RoR2.HurtBox)
>>>v bullseyeCount = 1
>>>v _hurtBoxesDeactivatorCounter = 0
>>>v hurtBoxesDeactivatorCounter = 0

>>> RoR2.ModelSkinController
>>>v skins = RoR2.SkinDef[]
>>>v <currentSkinIndex>k__BackingField = -1
>>>v characterModel = 
>>>v currentSkinIndex = -1

>>> RoR2.HitBoxGroup
>>>v groupName = PunchLollypop
>>>v hitBoxes = RoR2.HitBox[]

>>> Generics.Dynamics.InverseKinematics
>>>v solver = CyclicDescend
>>>v rArm = Generics.Dynamics.Core+Chain
>>>v lArm = Generics.Dynamics.Core+Chain
>>>v rLeg = Generics.Dynamics.Core+Chain
>>>v lLeg = Generics.Dynamics.Core+Chain
>>>v otherChains = Generics.Dynamics.Core+Chain[]
>>>v otherKChains = Generics.Dynamics.Core+KinematicChain[]
>>>v rigReader = 
>>>v animator = mdlLoader (UnityEngine.Animator)

>>> ChildLocator
>>>v transformPairs = ChildLocator+NameTransformPair[]
>>>v Count = 35

>>> RoR2.SprintEffectController
>>>v loopSystems = UnityEngine.ParticleSystem[]
>>>v loopRootObject = SprintLoopSound (UnityEngine.GameObject)
>>>v mustBeGrounded = False
>>>v mustBeVisible = False
>>>v characterBody = LoaderBody (RoR2.CharacterBody)
>>>v characterModel = 

>>> RoR2.ModelPanelParameters
>>>v focusPointTransform = LogbookTarget (UnityEngine.Transform)
>>>v cameraPositionTransform = LogbookCamera (UnityEngine.Transform)
>>>v modelRotation = (0.0, 0.0, 0.0, 1.0)
>>>v minDistance = 1
>>>v maxDistance = 3
>>>v cameraDirection = (0.5, -0.2, -0.8)

>>>GameObject Children 0 LoaderArmature

>>>> transform = p: (0.0, 0.0, 0.0) r: (270.0, 359.9, 0.0) s: (1.0, 1.0, 1.0)
>>>>GameObject Children 0 ROOT

>>>>> transform = p: (0.0, 0.0, 0.0) r: (0.0, 359.9, 0.2) s: (1.0, 1.0, 1.0)
>>>>>GameObject Children 0 base

>>>>>> transform = p: (0.0, 1.3, -0.1) r: (90.0, 359.9, 0.0) s: (1.0, 1.0, 1.0)
>>>>>>GameObject Children 0 IKArmTarget.l

>>>>>>> transform = p: (-0.4, -0.2, -0.1) r: (270.0, 359.9, 0.0) s: (1.0, 1.0, 1.0)
>>>>>>>GameObject Children 0 IKArmPole.l

>>>>>>>> transform = p: (-0.2, -1.3, 0.1) r: (270.0, 359.9, 0.0) s: (1.0, 1.0, 1.0)
>>>>>>>>GameObject Children 0 IKArmPole.l_end

>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (270.0, 359.9, 0.0) s: (1.0, 1.0, 1.0)
>>>>>>GameObject Children 1 IKArmTarget.r

>>>>>>> transform = p: (0.4, -0.1, 0.0) r: (270.0, 359.9, 0.0) s: (1.0, 1.0, 1.0)
>>>>>>>GameObject Children 0 IKArmPole.r

>>>>>>>> transform = p: (0.7, 1.2, 0.1) r: (270.0, 359.9, 0.0) s: (1.0, 1.0, 1.0)
>>>>>>>>GameObject Children 0 IKArmPole.r_end

>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (270.0, 359.9, 0.0) s: (1.0, 1.0, 1.0)
>>>>>>GameObject Children 2 mech.IKArmTarget.l

>>>>>>> transform = p: (-0.4, 0.0, 0.3) r: (0.0, 359.9, 0.0) s: (1.0, 1.0, 1.0)
>>>>>>>GameObject Children 0 mech.IKArmPole.l

>>>>>>>> transform = p: (-0.6, 1.4, 0.5) r: (0.0, 359.9, 0.0) s: (1.0, 1.0, 1.0)
>>>>>>>>GameObject Children 0 mech.IKArmPole.l_end

>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (0.0, 359.9, 0.0) s: (1.0, 1.0, 1.0)
>>>>>>GameObject Children 3 mech.IKArmTarget.r

>>>>>>> transform = p: (0.5, 0.0, 0.4) r: (270.0, 359.9, 0.0) s: (1.0, 1.0, 1.0)
>>>>>>>GameObject Children 0 mech.IKArmPole.r

>>>>>>>> transform = p: (0.6, 1.4, 0.5) r: (270.0, 359.9, 0.0) s: (1.0, 1.0, 1.0)
>>>>>>>>GameObject Children 0 mech.IKArmPole.r_end

>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (270.0, 359.9, 0.0) s: (1.0, 1.0, 1.0)
>>>>>>GameObject Children 4 pelvis

>>>>>>> transform = p: (0.0, 0.0, 0.0) r: (9.1, 179.9, 180.0) s: (1.0, 1.0, 1.0)
>>>>>>> UnityEngine.Rigidbody
>>>>>>>v velocity = (0.0, 0.0, 0.0)
>>>>>>>v angularVelocity = (0.0, 0.0, 0.0)
>>>>>>>v drag = 0
>>>>>>>v angularDrag = 0,05
>>>>>>>v mass = 1
>>>>>>>v useGravity = True
>>>>>>>v maxDepenetrationVelocity = 1E+32
>>>>>>>v isKinematic = True
>>>>>>>v freezeRotation = False
>>>>>>>v constraints = None
>>>>>>>v collisionDetectionMode = Discrete
>>>>>>>v centerOfMass = (0.0, 0.0, 0.0)
>>>>>>>v worldCenterOfMass = (0.0, 0.0, 0.0)
>>>>>>>v inertiaTensorRotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>v inertiaTensor = (1.0, 1.0, 1.0)
>>>>>>>v detectCollisions = True
>>>>>>>v position = (0.0, 0.0, 0.0)
>>>>>>>v rotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>v interpolation = Interpolate
>>>>>>>v solverIterations = 6
>>>>>>>v sleepThreshold = 0,005
>>>>>>>v maxAngularVelocity = 7
>>>>>>>v solverVelocityIterations = 1
>>>>>>>v sleepVelocity = 0
>>>>>>>v sleepAngularVelocity = 0
>>>>>>>v useConeFriction = False
>>>>>>>v solverIterationCount = 6
>>>>>>>v solverVelocityIterationCount = 1

>>>>>>> UnityEngine.CapsuleCollider
>>>>>>>v center = (0.0, 0.0, 0.0)
>>>>>>>v radius = 0,08
>>>>>>>v height = 0,58
>>>>>>>v direction = 0

>>>>>>>GameObject Children 0 thigh.l

>>>>>>>> transform = p: (-0.1, 0.1, 0.1) r: (355.7, 330.9, 169.6) s: (1.0, 1.0, 1.0)
>>>>>>>> UnityEngine.Rigidbody
>>>>>>>>v velocity = (0.0, 0.0, 0.0)
>>>>>>>>v angularVelocity = (0.0, 0.0, 0.0)
>>>>>>>>v drag = 0
>>>>>>>>v angularDrag = 0,05
>>>>>>>>v mass = 1
>>>>>>>>v useGravity = True
>>>>>>>>v maxDepenetrationVelocity = 1E+32
>>>>>>>>v isKinematic = True
>>>>>>>>v freezeRotation = False
>>>>>>>>v constraints = None
>>>>>>>>v collisionDetectionMode = Discrete
>>>>>>>>v centerOfMass = (0.0, 0.0, 0.0)
>>>>>>>>v worldCenterOfMass = (0.0, 0.0, 0.0)
>>>>>>>>v inertiaTensorRotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>>v inertiaTensor = (1.0, 1.0, 1.0)
>>>>>>>>v detectCollisions = True
>>>>>>>>v position = (0.0, 0.0, 0.0)
>>>>>>>>v rotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>>v interpolation = Interpolate
>>>>>>>>v solverIterations = 6
>>>>>>>>v sleepThreshold = 0,005
>>>>>>>>v maxAngularVelocity = 7
>>>>>>>>v solverVelocityIterations = 1
>>>>>>>>v sleepVelocity = 0
>>>>>>>>v sleepAngularVelocity = 0
>>>>>>>>v useConeFriction = False
>>>>>>>>v solverIterationCount = 6
>>>>>>>>v solverVelocityIterationCount = 1

>>>>>>>> UnityEngine.CapsuleCollider
>>>>>>>>v center = (0.0, 0.3, 0.0)
>>>>>>>>v radius = 0,13
>>>>>>>>v height = 0,54
>>>>>>>>v direction = 1

>>>>>>>> UnityEngine.CharacterJoint
>>>>>>>>v targetRotation = (0.0, 0.0, 0.0, 0.0)
>>>>>>>>v targetAngularVelocity = (0.0, 0.0, 0.0)
>>>>>>>>v rotationDrive = UnityEngine.JointDrive
>>>>>>>>v swingAxis = (0.0, 1.0, 0.0)
>>>>>>>>v twistLimitSpring = UnityEngine.SoftJointLimitSpring
>>>>>>>>v swingLimitSpring = UnityEngine.SoftJointLimitSpring
>>>>>>>>v lowTwistLimit = UnityEngine.SoftJointLimit
>>>>>>>>v highTwistLimit = UnityEngine.SoftJointLimit
>>>>>>>>v swing1Limit = UnityEngine.SoftJointLimit
>>>>>>>>v swing2Limit = UnityEngine.SoftJointLimit
>>>>>>>>v enableProjection = False
>>>>>>>>v projectionDistance = 0,1
>>>>>>>>v projectionAngle = 180

>>>>>>>>GameObject Children 0 calf.l

>>>>>>>>> transform = p: (0.0, 0.6, 0.0) r: (350.9, 149.6, 186.9) s: (1.0, 1.0, 1.0)
>>>>>>>>> UnityEngine.Rigidbody
>>>>>>>>>v velocity = (0.0, 0.0, 0.0)
>>>>>>>>>v angularVelocity = (0.0, 0.0, 0.0)
>>>>>>>>>v drag = 0
>>>>>>>>>v angularDrag = 0,05
>>>>>>>>>v mass = 1
>>>>>>>>>v useGravity = True
>>>>>>>>>v maxDepenetrationVelocity = 1E+32
>>>>>>>>>v isKinematic = True
>>>>>>>>>v freezeRotation = False
>>>>>>>>>v constraints = None
>>>>>>>>>v collisionDetectionMode = Discrete
>>>>>>>>>v centerOfMass = (0.0, 0.0, 0.0)
>>>>>>>>>v worldCenterOfMass = (0.0, 0.0, 0.0)
>>>>>>>>>v inertiaTensorRotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>>>v inertiaTensor = (1.0, 1.0, 1.0)
>>>>>>>>>v detectCollisions = True
>>>>>>>>>v position = (0.0, 0.0, 0.0)
>>>>>>>>>v rotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>>>v interpolation = Interpolate
>>>>>>>>>v solverIterations = 6
>>>>>>>>>v sleepThreshold = 0,005
>>>>>>>>>v maxAngularVelocity = 7
>>>>>>>>>v solverVelocityIterations = 1
>>>>>>>>>v sleepVelocity = 0
>>>>>>>>>v sleepAngularVelocity = 0
>>>>>>>>>v useConeFriction = False
>>>>>>>>>v solverIterationCount = 6
>>>>>>>>>v solverVelocityIterationCount = 1

>>>>>>>>> UnityEngine.CapsuleCollider
>>>>>>>>>v center = (0.0, 0.2, 0.0)
>>>>>>>>>v radius = 0,11
>>>>>>>>>v height = 0,56
>>>>>>>>>v direction = 1

>>>>>>>>> UnityEngine.CharacterJoint
>>>>>>>>>v targetRotation = (0.0, 0.0, 0.0, 0.0)
>>>>>>>>>v targetAngularVelocity = (0.0, 0.0, 0.0)
>>>>>>>>>v rotationDrive = UnityEngine.JointDrive
>>>>>>>>>v swingAxis = (0.0, 1.0, 0.0)
>>>>>>>>>v twistLimitSpring = UnityEngine.SoftJointLimitSpring
>>>>>>>>>v swingLimitSpring = UnityEngine.SoftJointLimitSpring
>>>>>>>>>v lowTwistLimit = UnityEngine.SoftJointLimit
>>>>>>>>>v highTwistLimit = UnityEngine.SoftJointLimit
>>>>>>>>>v swing1Limit = UnityEngine.SoftJointLimit
>>>>>>>>>v swing2Limit = UnityEngine.SoftJointLimit
>>>>>>>>>v enableProjection = False
>>>>>>>>>v projectionDistance = 0,1
>>>>>>>>>v projectionAngle = 180

>>>>>>>>>GameObject Children 0 foot.l

>>>>>>>>>> transform = p: (0.0, 0.5, 0.0) r: (31.5, 179.4, 192.8) s: (1.0, 1.0, 1.0)
>>>>>>>>>>GameObject Children 0 toe.l

>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (280.9, 56.5, 99.0) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>GameObject Children 0 toe.l_end

>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (280.9, 56.5, 99.0) s: (1.0, 1.0, 1.0)
>>>>>>>GameObject Children 1 thigh.r

>>>>>>>> transform = p: (0.1, 0.1, 0.1) r: (346.9, 22.6, 185.7) s: (1.0, 1.0, 1.0)
>>>>>>>> UnityEngine.Rigidbody
>>>>>>>>v velocity = (0.0, 0.0, 0.0)
>>>>>>>>v angularVelocity = (0.0, 0.0, 0.0)
>>>>>>>>v drag = 0
>>>>>>>>v angularDrag = 0,05
>>>>>>>>v mass = 1
>>>>>>>>v useGravity = True
>>>>>>>>v maxDepenetrationVelocity = 1E+32
>>>>>>>>v isKinematic = True
>>>>>>>>v freezeRotation = False
>>>>>>>>v constraints = None
>>>>>>>>v collisionDetectionMode = Discrete
>>>>>>>>v centerOfMass = (0.0, 0.0, 0.0)
>>>>>>>>v worldCenterOfMass = (0.0, 0.0, 0.0)
>>>>>>>>v inertiaTensorRotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>>v inertiaTensor = (1.0, 1.0, 1.0)
>>>>>>>>v detectCollisions = True
>>>>>>>>v position = (0.0, 0.0, 0.0)
>>>>>>>>v rotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>>v interpolation = Interpolate
>>>>>>>>v solverIterations = 6
>>>>>>>>v sleepThreshold = 0,005
>>>>>>>>v maxAngularVelocity = 7
>>>>>>>>v solverVelocityIterations = 1
>>>>>>>>v sleepVelocity = 0
>>>>>>>>v sleepAngularVelocity = 0
>>>>>>>>v useConeFriction = False
>>>>>>>>v solverIterationCount = 6
>>>>>>>>v solverVelocityIterationCount = 1

>>>>>>>> UnityEngine.CapsuleCollider
>>>>>>>>v center = (0.0, 0.3, 0.0)
>>>>>>>>v radius = 0,13
>>>>>>>>v height = 0,54
>>>>>>>>v direction = 1

>>>>>>>> UnityEngine.CharacterJoint
>>>>>>>>v targetRotation = (0.0, 0.0, 0.0, 0.0)
>>>>>>>>v targetAngularVelocity = (0.0, 0.0, 0.0)
>>>>>>>>v rotationDrive = UnityEngine.JointDrive
>>>>>>>>v swingAxis = (0.0, 1.0, 0.0)
>>>>>>>>v twistLimitSpring = UnityEngine.SoftJointLimitSpring
>>>>>>>>v swingLimitSpring = UnityEngine.SoftJointLimitSpring
>>>>>>>>v lowTwistLimit = UnityEngine.SoftJointLimit
>>>>>>>>v highTwistLimit = UnityEngine.SoftJointLimit
>>>>>>>>v swing1Limit = UnityEngine.SoftJointLimit
>>>>>>>>v swing2Limit = UnityEngine.SoftJointLimit
>>>>>>>>v enableProjection = False
>>>>>>>>v projectionDistance = 0,1
>>>>>>>>v projectionAngle = 180

>>>>>>>>GameObject Children 0 calf.r

>>>>>>>>> transform = p: (0.0, 0.6, 0.0) r: (5.5, 199.9, 175.6) s: (1.0, 1.0, 1.0)
>>>>>>>>> UnityEngine.Rigidbody
>>>>>>>>>v velocity = (0.0, 0.0, 0.0)
>>>>>>>>>v angularVelocity = (0.0, 0.0, 0.0)
>>>>>>>>>v drag = 0
>>>>>>>>>v angularDrag = 0,05
>>>>>>>>>v mass = 1
>>>>>>>>>v useGravity = True
>>>>>>>>>v maxDepenetrationVelocity = 1E+32
>>>>>>>>>v isKinematic = True
>>>>>>>>>v freezeRotation = False
>>>>>>>>>v constraints = None
>>>>>>>>>v collisionDetectionMode = Discrete
>>>>>>>>>v centerOfMass = (0.0, 0.0, 0.0)
>>>>>>>>>v worldCenterOfMass = (0.0, 0.0, 0.0)
>>>>>>>>>v inertiaTensorRotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>>>v inertiaTensor = (1.0, 1.0, 1.0)
>>>>>>>>>v detectCollisions = True
>>>>>>>>>v position = (0.0, 0.0, 0.0)
>>>>>>>>>v rotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>>>v interpolation = Interpolate
>>>>>>>>>v solverIterations = 6
>>>>>>>>>v sleepThreshold = 0,005
>>>>>>>>>v maxAngularVelocity = 7
>>>>>>>>>v solverVelocityIterations = 1
>>>>>>>>>v sleepVelocity = 0
>>>>>>>>>v sleepAngularVelocity = 0
>>>>>>>>>v useConeFriction = False
>>>>>>>>>v solverIterationCount = 6
>>>>>>>>>v solverVelocityIterationCount = 1

>>>>>>>>> UnityEngine.CapsuleCollider
>>>>>>>>>v center = (0.0, 0.2, 0.0)
>>>>>>>>>v radius = 0,11
>>>>>>>>>v height = 0,56
>>>>>>>>>v direction = 1

>>>>>>>>> UnityEngine.CharacterJoint
>>>>>>>>>v targetRotation = (0.0, 0.0, 0.0, 0.0)
>>>>>>>>>v targetAngularVelocity = (0.0, 0.0, 0.0)
>>>>>>>>>v rotationDrive = UnityEngine.JointDrive
>>>>>>>>>v swingAxis = (0.0, 1.0, 0.0)
>>>>>>>>>v twistLimitSpring = UnityEngine.SoftJointLimitSpring
>>>>>>>>>v swingLimitSpring = UnityEngine.SoftJointLimitSpring
>>>>>>>>>v lowTwistLimit = UnityEngine.SoftJointLimit
>>>>>>>>>v highTwistLimit = UnityEngine.SoftJointLimit
>>>>>>>>>v swing1Limit = UnityEngine.SoftJointLimit
>>>>>>>>>v swing2Limit = UnityEngine.SoftJointLimit
>>>>>>>>>v enableProjection = False
>>>>>>>>>v projectionDistance = 0,1
>>>>>>>>>v projectionAngle = 180

>>>>>>>>>GameObject Children 0 foot.r

>>>>>>>>>> transform = p: (0.0, 0.5, 0.0) r: (31.0, 179.8, 169.1) s: (1.0, 1.0, 1.0)
>>>>>>>>>>GameObject Children 0 toe.r

>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (279.8, 306.4, 253.7) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>GameObject Children 0 toe.r_end

>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (279.8, 306.4, 253.7) s: (1.0, 1.0, 1.0)
>>>>>>GameObject Children 5 stomach

>>>>>>> transform = p: (0.0, 0.0, 0.0) r: (357.0, 0.3, 0.3) s: (1.0, 1.0, 1.0)
>>>>>>> UnityEngine.Rigidbody
>>>>>>>v velocity = (0.0, 0.0, 0.0)
>>>>>>>v angularVelocity = (0.0, 0.0, 0.0)
>>>>>>>v drag = 0
>>>>>>>v angularDrag = 0,05
>>>>>>>v mass = 1
>>>>>>>v useGravity = True
>>>>>>>v maxDepenetrationVelocity = 1E+32
>>>>>>>v isKinematic = True
>>>>>>>v freezeRotation = False
>>>>>>>v constraints = None
>>>>>>>v collisionDetectionMode = Discrete
>>>>>>>v centerOfMass = (0.0, 0.0, 0.0)
>>>>>>>v worldCenterOfMass = (0.0, 0.0, 0.0)
>>>>>>>v inertiaTensorRotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>v inertiaTensor = (1.0, 1.0, 1.0)
>>>>>>>v detectCollisions = True
>>>>>>>v position = (0.0, 0.0, 0.0)
>>>>>>>v rotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>v interpolation = Interpolate
>>>>>>>v solverIterations = 6
>>>>>>>v sleepThreshold = 0,005
>>>>>>>v maxAngularVelocity = 7
>>>>>>>v solverVelocityIterations = 1
>>>>>>>v sleepVelocity = 0
>>>>>>>v sleepAngularVelocity = 0
>>>>>>>v useConeFriction = False
>>>>>>>v solverIterationCount = 6
>>>>>>>v solverVelocityIterationCount = 1

>>>>>>> UnityEngine.CapsuleCollider
>>>>>>>v center = (0.0, 0.2, 0.0)
>>>>>>>v radius = 0,07
>>>>>>>v height = 0,55
>>>>>>>v direction = 0

>>>>>>> UnityEngine.CharacterJoint
>>>>>>>v targetRotation = (0.0, 0.0, 0.0, 0.0)
>>>>>>>v targetAngularVelocity = (0.0, 0.0, 0.0)
>>>>>>>v rotationDrive = UnityEngine.JointDrive
>>>>>>>v swingAxis = (0.0, 1.0, 0.0)
>>>>>>>v twistLimitSpring = UnityEngine.SoftJointLimitSpring
>>>>>>>v swingLimitSpring = UnityEngine.SoftJointLimitSpring
>>>>>>>v lowTwistLimit = UnityEngine.SoftJointLimit
>>>>>>>v highTwistLimit = UnityEngine.SoftJointLimit
>>>>>>>v swing1Limit = UnityEngine.SoftJointLimit
>>>>>>>v swing2Limit = UnityEngine.SoftJointLimit
>>>>>>>v enableProjection = False
>>>>>>>v projectionDistance = 0,1
>>>>>>>v projectionAngle = 180

>>>>>>>GameObject Children 0 chest

>>>>>>>> transform = p: (0.0, 0.2, 0.0) r: (353.9, 0.3, 360.0) s: (1.0, 1.0, 1.0)
>>>>>>>> UnityEngine.Rigidbody
>>>>>>>>v velocity = (0.0, 0.0, 0.0)
>>>>>>>>v angularVelocity = (0.0, 0.0, 0.0)
>>>>>>>>v drag = 0
>>>>>>>>v angularDrag = 0,05
>>>>>>>>v mass = 1
>>>>>>>>v useGravity = True
>>>>>>>>v maxDepenetrationVelocity = 1E+32
>>>>>>>>v isKinematic = True
>>>>>>>>v freezeRotation = False
>>>>>>>>v constraints = None
>>>>>>>>v collisionDetectionMode = Discrete
>>>>>>>>v centerOfMass = (0.0, 0.0, 0.0)
>>>>>>>>v worldCenterOfMass = (0.0, 0.0, 0.0)
>>>>>>>>v inertiaTensorRotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>>v inertiaTensor = (1.0, 1.0, 1.0)
>>>>>>>>v detectCollisions = True
>>>>>>>>v position = (0.0, 0.0, 0.0)
>>>>>>>>v rotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>>v interpolation = Interpolate
>>>>>>>>v solverIterations = 6
>>>>>>>>v sleepThreshold = 0,005
>>>>>>>>v maxAngularVelocity = 7
>>>>>>>>v solverVelocityIterations = 1
>>>>>>>>v sleepVelocity = 0
>>>>>>>>v sleepAngularVelocity = 0
>>>>>>>>v useConeFriction = False
>>>>>>>>v solverIterationCount = 6
>>>>>>>>v solverVelocityIterationCount = 1

>>>>>>>> UnityEngine.CapsuleCollider
>>>>>>>>v center = (0.0, 0.2, 0.0)
>>>>>>>>v radius = 0,15
>>>>>>>>v height = 0,54
>>>>>>>>v direction = 0

>>>>>>>> UnityEngine.CharacterJoint
>>>>>>>>v targetRotation = (0.0, 0.0, 0.0, 0.0)
>>>>>>>>v targetAngularVelocity = (0.0, 0.0, 0.0)
>>>>>>>>v rotationDrive = UnityEngine.JointDrive
>>>>>>>>v swingAxis = (0.0, 1.0, 0.0)
>>>>>>>>v twistLimitSpring = UnityEngine.SoftJointLimitSpring
>>>>>>>>v swingLimitSpring = UnityEngine.SoftJointLimitSpring
>>>>>>>>v lowTwistLimit = UnityEngine.SoftJointLimit
>>>>>>>>v highTwistLimit = UnityEngine.SoftJointLimit
>>>>>>>>v swing1Limit = UnityEngine.SoftJointLimit
>>>>>>>>v swing2Limit = UnityEngine.SoftJointLimit
>>>>>>>>v enableProjection = False
>>>>>>>>v projectionDistance = 0,1
>>>>>>>>v projectionAngle = 180

>>>>>>>>GameObject Children 0 clavicle.l

>>>>>>>>> transform = p: (0.0, 0.3, 0.0) r: (36.1, 132.0, 249.6) s: (1.0, 1.0, 1.0)
>>>>>>>>> UnityEngine.Rigidbody
>>>>>>>>>v velocity = (0.0, 0.0, 0.0)
>>>>>>>>>v angularVelocity = (0.0, 0.0, 0.0)
>>>>>>>>>v drag = 0
>>>>>>>>>v angularDrag = 0,05
>>>>>>>>>v mass = 1
>>>>>>>>>v useGravity = True
>>>>>>>>>v maxDepenetrationVelocity = 1E+32
>>>>>>>>>v isKinematic = True
>>>>>>>>>v freezeRotation = False
>>>>>>>>>v constraints = None
>>>>>>>>>v collisionDetectionMode = Discrete
>>>>>>>>>v centerOfMass = (0.0, 0.0, 0.0)
>>>>>>>>>v worldCenterOfMass = (0.0, 0.0, 0.0)
>>>>>>>>>v inertiaTensorRotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>>>v inertiaTensor = (1.0, 1.0, 1.0)
>>>>>>>>>v detectCollisions = True
>>>>>>>>>v position = (0.0, 0.0, 0.0)
>>>>>>>>>v rotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>>>v interpolation = Interpolate
>>>>>>>>>v solverIterations = 6
>>>>>>>>>v sleepThreshold = 0,005
>>>>>>>>>v maxAngularVelocity = 7
>>>>>>>>>v solverVelocityIterations = 1
>>>>>>>>>v sleepVelocity = 0
>>>>>>>>>v sleepAngularVelocity = 0
>>>>>>>>>v useConeFriction = False
>>>>>>>>>v solverIterationCount = 6
>>>>>>>>>v solverVelocityIterationCount = 1

>>>>>>>>> UnityEngine.CapsuleCollider
>>>>>>>>>v center = (0.0, 0.2, 0.0)
>>>>>>>>>v radius = 0,05
>>>>>>>>>v height = 0,15
>>>>>>>>>v direction = 0

>>>>>>>>> UnityEngine.CharacterJoint
>>>>>>>>>v targetRotation = (0.0, 0.0, 0.0, 0.0)
>>>>>>>>>v targetAngularVelocity = (0.0, 0.0, 0.0)
>>>>>>>>>v rotationDrive = UnityEngine.JointDrive
>>>>>>>>>v swingAxis = (0.0, 1.0, 0.0)
>>>>>>>>>v twistLimitSpring = UnityEngine.SoftJointLimitSpring
>>>>>>>>>v swingLimitSpring = UnityEngine.SoftJointLimitSpring
>>>>>>>>>v lowTwistLimit = UnityEngine.SoftJointLimit
>>>>>>>>>v highTwistLimit = UnityEngine.SoftJointLimit
>>>>>>>>>v swing1Limit = UnityEngine.SoftJointLimit
>>>>>>>>>v swing2Limit = UnityEngine.SoftJointLimit
>>>>>>>>>v enableProjection = False
>>>>>>>>>v projectionDistance = 0,1
>>>>>>>>>v projectionAngle = 180

>>>>>>>>>GameObject Children 0 upper_arm.l

>>>>>>>>>> transform = p: (0.0, 0.2, 0.0) r: (65.2, 360.0, 149.7) s: (1.0, 1.0, 1.0)
>>>>>>>>>> UnityEngine.Rigidbody
>>>>>>>>>>v velocity = (0.0, 0.0, 0.0)
>>>>>>>>>>v angularVelocity = (0.0, 0.0, 0.0)
>>>>>>>>>>v drag = 0
>>>>>>>>>>v angularDrag = 0,05
>>>>>>>>>>v mass = 1
>>>>>>>>>>v useGravity = True
>>>>>>>>>>v maxDepenetrationVelocity = 1E+32
>>>>>>>>>>v isKinematic = True
>>>>>>>>>>v freezeRotation = False
>>>>>>>>>>v constraints = None
>>>>>>>>>>v collisionDetectionMode = Discrete
>>>>>>>>>>v centerOfMass = (0.0, 0.0, 0.0)
>>>>>>>>>>v worldCenterOfMass = (0.0, 0.0, 0.0)
>>>>>>>>>>v inertiaTensorRotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>>>>v inertiaTensor = (1.0, 1.0, 1.0)
>>>>>>>>>>v detectCollisions = True
>>>>>>>>>>v position = (0.0, 0.0, 0.0)
>>>>>>>>>>v rotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>>>>v interpolation = Interpolate
>>>>>>>>>>v solverIterations = 6
>>>>>>>>>>v sleepThreshold = 0,005
>>>>>>>>>>v maxAngularVelocity = 7
>>>>>>>>>>v solverVelocityIterations = 1
>>>>>>>>>>v sleepVelocity = 0
>>>>>>>>>>v sleepAngularVelocity = 0
>>>>>>>>>>v useConeFriction = False
>>>>>>>>>>v solverIterationCount = 6
>>>>>>>>>>v solverVelocityIterationCount = 1

>>>>>>>>>> UnityEngine.CapsuleCollider
>>>>>>>>>>v center = (0.0, 0.2, 0.0)
>>>>>>>>>>v radius = 0,07
>>>>>>>>>>v height = 0,33
>>>>>>>>>>v direction = 1

>>>>>>>>>> UnityEngine.CharacterJoint
>>>>>>>>>>v targetRotation = (0.0, 0.0, 0.0, 0.0)
>>>>>>>>>>v targetAngularVelocity = (0.0, 0.0, 0.0)
>>>>>>>>>>v rotationDrive = UnityEngine.JointDrive
>>>>>>>>>>v swingAxis = (0.0, 1.0, 0.0)
>>>>>>>>>>v twistLimitSpring = UnityEngine.SoftJointLimitSpring
>>>>>>>>>>v swingLimitSpring = UnityEngine.SoftJointLimitSpring
>>>>>>>>>>v lowTwistLimit = UnityEngine.SoftJointLimit
>>>>>>>>>>v highTwistLimit = UnityEngine.SoftJointLimit
>>>>>>>>>>v swing1Limit = UnityEngine.SoftJointLimit
>>>>>>>>>>v swing2Limit = UnityEngine.SoftJointLimit
>>>>>>>>>>v enableProjection = False
>>>>>>>>>>v projectionDistance = 0,1
>>>>>>>>>>v projectionAngle = 180

>>>>>>>>>>GameObject Children 0 lower_arm.l

>>>>>>>>>>> transform = p: (0.0, 0.3, 0.0) r: (35.9, 128.6, 163.2) s: (1.0, 1.0, 1.0)
>>>>>>>>>>> UnityEngine.Rigidbody
>>>>>>>>>>>v velocity = (0.0, 0.0, 0.0)
>>>>>>>>>>>v angularVelocity = (0.0, 0.0, 0.0)
>>>>>>>>>>>v drag = 0
>>>>>>>>>>>v angularDrag = 0,05
>>>>>>>>>>>v mass = 1
>>>>>>>>>>>v useGravity = True
>>>>>>>>>>>v maxDepenetrationVelocity = 1E+32
>>>>>>>>>>>v isKinematic = True
>>>>>>>>>>>v freezeRotation = False
>>>>>>>>>>>v constraints = None
>>>>>>>>>>>v collisionDetectionMode = Discrete
>>>>>>>>>>>v centerOfMass = (0.0, 0.0, 0.0)
>>>>>>>>>>>v worldCenterOfMass = (0.0, 0.0, 0.0)
>>>>>>>>>>>v inertiaTensorRotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>>>>>v inertiaTensor = (1.0, 1.0, 1.0)
>>>>>>>>>>>v detectCollisions = True
>>>>>>>>>>>v position = (0.0, 0.0, 0.0)
>>>>>>>>>>>v rotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>>>>>v interpolation = Interpolate
>>>>>>>>>>>v solverIterations = 6
>>>>>>>>>>>v sleepThreshold = 0,005
>>>>>>>>>>>v maxAngularVelocity = 7
>>>>>>>>>>>v solverVelocityIterations = 1
>>>>>>>>>>>v sleepVelocity = 0
>>>>>>>>>>>v sleepAngularVelocity = 0
>>>>>>>>>>>v useConeFriction = False
>>>>>>>>>>>v solverIterationCount = 6
>>>>>>>>>>>v solverVelocityIterationCount = 1

>>>>>>>>>>> UnityEngine.CapsuleCollider
>>>>>>>>>>>v center = (0.0, 0.2, 0.0)
>>>>>>>>>>>v radius = 0,07
>>>>>>>>>>>v height = 0,24
>>>>>>>>>>>v direction = 1

>>>>>>>>>>> UnityEngine.CharacterJoint
>>>>>>>>>>>v targetRotation = (0.0, 0.0, 0.0, 0.0)
>>>>>>>>>>>v targetAngularVelocity = (0.0, 0.0, 0.0)
>>>>>>>>>>>v rotationDrive = UnityEngine.JointDrive
>>>>>>>>>>>v swingAxis = (0.0, 1.0, 0.0)
>>>>>>>>>>>v twistLimitSpring = UnityEngine.SoftJointLimitSpring
>>>>>>>>>>>v swingLimitSpring = UnityEngine.SoftJointLimitSpring
>>>>>>>>>>>v lowTwistLimit = UnityEngine.SoftJointLimit
>>>>>>>>>>>v highTwistLimit = UnityEngine.SoftJointLimit
>>>>>>>>>>>v swing1Limit = UnityEngine.SoftJointLimit
>>>>>>>>>>>v swing2Limit = UnityEngine.SoftJointLimit
>>>>>>>>>>>v enableProjection = False
>>>>>>>>>>>v projectionDistance = 0,1
>>>>>>>>>>>v projectionAngle = 180

>>>>>>>>>>>GameObject Children 0 hand.l

>>>>>>>>>>>> transform = p: (0.0, 0.3, 0.0) r: (335.2, 317.0, 215.6) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>> UnityEngine.Rigidbody
>>>>>>>>>>>>v velocity = (0.0, 0.0, 0.0)
>>>>>>>>>>>>v angularVelocity = (0.0, 0.0, 0.0)
>>>>>>>>>>>>v drag = 0
>>>>>>>>>>>>v angularDrag = 0,05
>>>>>>>>>>>>v mass = 1
>>>>>>>>>>>>v useGravity = True
>>>>>>>>>>>>v maxDepenetrationVelocity = 1E+32
>>>>>>>>>>>>v isKinematic = True
>>>>>>>>>>>>v freezeRotation = False
>>>>>>>>>>>>v constraints = None
>>>>>>>>>>>>v collisionDetectionMode = Discrete
>>>>>>>>>>>>v centerOfMass = (0.0, 0.0, 0.0)
>>>>>>>>>>>>v worldCenterOfMass = (0.0, 0.0, 0.0)
>>>>>>>>>>>>v inertiaTensorRotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>>>>>>v inertiaTensor = (1.0, 1.0, 1.0)
>>>>>>>>>>>>v detectCollisions = True
>>>>>>>>>>>>v position = (0.0, 0.0, 0.0)
>>>>>>>>>>>>v rotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>>>>>>v interpolation = Interpolate
>>>>>>>>>>>>v solverIterations = 6
>>>>>>>>>>>>v sleepThreshold = 0,005
>>>>>>>>>>>>v maxAngularVelocity = 7
>>>>>>>>>>>>v solverVelocityIterations = 1
>>>>>>>>>>>>v sleepVelocity = 0
>>>>>>>>>>>>v sleepAngularVelocity = 0
>>>>>>>>>>>>v useConeFriction = False
>>>>>>>>>>>>v solverIterationCount = 6
>>>>>>>>>>>>v solverVelocityIterationCount = 1

>>>>>>>>>>>> UnityEngine.CapsuleCollider
>>>>>>>>>>>>v center = (0.0, 0.1, 0.0)
>>>>>>>>>>>>v radius = 0,06
>>>>>>>>>>>>v height = 0,18
>>>>>>>>>>>>v direction = 1

>>>>>>>>>>>> UnityEngine.CharacterJoint
>>>>>>>>>>>>v targetRotation = (0.0, 0.0, 0.0, 0.0)
>>>>>>>>>>>>v targetAngularVelocity = (0.0, 0.0, 0.0)
>>>>>>>>>>>>v rotationDrive = UnityEngine.JointDrive
>>>>>>>>>>>>v swingAxis = (0.0, 1.0, 0.0)
>>>>>>>>>>>>v twistLimitSpring = UnityEngine.SoftJointLimitSpring
>>>>>>>>>>>>v swingLimitSpring = UnityEngine.SoftJointLimitSpring
>>>>>>>>>>>>v lowTwistLimit = UnityEngine.SoftJointLimit
>>>>>>>>>>>>v highTwistLimit = UnityEngine.SoftJointLimit
>>>>>>>>>>>>v swing1Limit = UnityEngine.SoftJointLimit
>>>>>>>>>>>>v swing2Limit = UnityEngine.SoftJointLimit
>>>>>>>>>>>>v enableProjection = False
>>>>>>>>>>>>v projectionDistance = 0,1
>>>>>>>>>>>>v projectionAngle = 180

>>>>>>>>>>>>GameObject Children 0 finger1.1.l

>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (280.8, 77.5, 76.3) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>GameObject Children 0 finger1.2.l

>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (9.2, 139.1, 224.4) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>GameObject Children 0 finger1.3.l

>>>>>>>>>>>>>>> transform = p: (0.0, 0.0, 0.0) r: (339.3, 95.0, 259.2) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>>GameObject Children 0 finger1.3.l_end

>>>>>>>>>>>>>>>> transform = p: (0.0, 0.0, 0.0) r: (339.3, 95.0, 259.2) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>GameObject Children 1 finger2.1.l

>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (285.2, 144.3, 12.1) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>GameObject Children 0 finger2.2.l

>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (4.9, 142.0, 209.7) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>GameObject Children 0 finger2.3.l

>>>>>>>>>>>>>>> transform = p: (0.0, 0.0, 0.0) r: (319.5, 92.6, 255.2) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>>GameObject Children 0 finger2.3.l_end

>>>>>>>>>>>>>>>> transform = p: (0.0, 0.0, 0.0) r: (319.5, 92.6, 255.2) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>GameObject Children 2 finger3.1.l

>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (304.7, 189.5, 332.2) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>GameObject Children 0 finger3.2.l

>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (14.4, 143.4, 177.3) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>GameObject Children 0 finger3.3.l

>>>>>>>>>>>>>>> transform = p: (0.0, 0.0, 0.0) r: (307.1, 129.9, 209.1) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>>GameObject Children 0 finger3.3.l_end

>>>>>>>>>>>>>>>> transform = p: (0.0, 0.0, 0.0) r: (307.1, 129.9, 209.1) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>GameObject Children 3 finger4.1.l

>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (315.9, 208.9, 306.5) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>GameObject Children 0 finger4.2.l

>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (9.5, 142.5, 141.5) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>GameObject Children 0 finger4.3.l

>>>>>>>>>>>>>>> transform = p: (0.0, 0.0, 0.0) r: (314.7, 186.4, 138.0) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>>GameObject Children 0 finger4.3.l_end

>>>>>>>>>>>>>>>> transform = p: (0.0, 0.0, 0.0) r: (314.7, 186.4, 138.0) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>GameObject Children 4 GripControl.l

>>>>>>>>>>>>> transform = p: (0.0, 0.2, 0.0) r: (53.7, 122.9, 55.3) s: (0.5, 0.5, 0.5)
>>>>>>>>>>>>>GameObject Children 0 finger1IKTarget.l

>>>>>>>>>>>>>> transform = p: (0.0, 0.0, 0.0) r: (358.2, 331.4, 199.7) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>GameObject Children 0 finger1IKTarget.l_end

>>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (358.2, 331.4, 199.7) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>GameObject Children 1 finger2IKTarget.l

>>>>>>>>>>>>>> transform = p: (0.0, 0.0, 0.0) r: (358.2, 331.4, 199.7) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>GameObject Children 0 finger2IKTarget.l_end

>>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (358.2, 331.4, 199.7) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>GameObject Children 2 finger3IKTarget.l

>>>>>>>>>>>>>> transform = p: (0.0, -0.1, 0.0) r: (358.2, 331.4, 199.7) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>GameObject Children 0 finger3IKTarget.l_end

>>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (358.2, 331.4, 199.7) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>GameObject Children 3 finger4IKTarget.l

>>>>>>>>>>>>>> transform = p: (0.0, -0.1, -0.1) r: (358.2, 331.4, 199.7) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>GameObject Children 0 finger4IKTarget.l_end

>>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (358.2, 331.4, 199.7) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>GameObject Children 4 thumbIKTarget.l

>>>>>>>>>>>>>> transform = p: (-0.1, 0.1, 0.0) r: (358.2, 331.4, 199.7) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>GameObject Children 0 thumbIKTarget.l_end

>>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (358.2, 331.4, 199.7) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>GameObject Children 5 thumb.1.l

>>>>>>>>>>>>> transform = p: (-0.1, 0.1, 0.0) r: (308.5, 319.6, 206.2) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>GameObject Children 0 thumb.2.l

>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (45.6, 124.6, 142.4) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>GameObject Children 0 thumb.2.l_end

>>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (45.6, 124.6, 142.4) s: (1.0, 1.0, 1.0)
>>>>>>>>GameObject Children 1 clavicle.r

>>>>>>>>> transform = p: (0.0, 0.3, 0.0) r: (36.3, 228.6, 115.2) s: (1.0, 1.0, 1.0)
>>>>>>>>> UnityEngine.Rigidbody
>>>>>>>>>v velocity = (0.0, 0.0, 0.0)
>>>>>>>>>v angularVelocity = (0.0, 0.0, 0.0)
>>>>>>>>>v drag = 0
>>>>>>>>>v angularDrag = 0,05
>>>>>>>>>v mass = 1
>>>>>>>>>v useGravity = True
>>>>>>>>>v maxDepenetrationVelocity = 1E+32
>>>>>>>>>v isKinematic = True
>>>>>>>>>v freezeRotation = False
>>>>>>>>>v constraints = None
>>>>>>>>>v collisionDetectionMode = Discrete
>>>>>>>>>v centerOfMass = (0.0, 0.0, 0.0)
>>>>>>>>>v worldCenterOfMass = (0.0, 0.0, 0.0)
>>>>>>>>>v inertiaTensorRotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>>>v inertiaTensor = (1.0, 1.0, 1.0)
>>>>>>>>>v detectCollisions = True
>>>>>>>>>v position = (0.0, 0.0, 0.0)
>>>>>>>>>v rotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>>>v interpolation = Interpolate
>>>>>>>>>v solverIterations = 6
>>>>>>>>>v sleepThreshold = 0,005
>>>>>>>>>v maxAngularVelocity = 7
>>>>>>>>>v solverVelocityIterations = 1
>>>>>>>>>v sleepVelocity = 0
>>>>>>>>>v sleepAngularVelocity = 0
>>>>>>>>>v useConeFriction = False
>>>>>>>>>v solverIterationCount = 6
>>>>>>>>>v solverVelocityIterationCount = 1

>>>>>>>>> UnityEngine.CapsuleCollider
>>>>>>>>>v center = (0.0, 0.2, 0.0)
>>>>>>>>>v radius = 0,05
>>>>>>>>>v height = 0,15
>>>>>>>>>v direction = 0

>>>>>>>>> UnityEngine.CharacterJoint
>>>>>>>>>v targetRotation = (0.0, 0.0, 0.0, 0.0)
>>>>>>>>>v targetAngularVelocity = (0.0, 0.0, 0.0)
>>>>>>>>>v rotationDrive = UnityEngine.JointDrive
>>>>>>>>>v swingAxis = (0.0, 1.0, 0.0)
>>>>>>>>>v twistLimitSpring = UnityEngine.SoftJointLimitSpring
>>>>>>>>>v swingLimitSpring = UnityEngine.SoftJointLimitSpring
>>>>>>>>>v lowTwistLimit = UnityEngine.SoftJointLimit
>>>>>>>>>v highTwistLimit = UnityEngine.SoftJointLimit
>>>>>>>>>v swing1Limit = UnityEngine.SoftJointLimit
>>>>>>>>>v swing2Limit = UnityEngine.SoftJointLimit
>>>>>>>>>v enableProjection = False
>>>>>>>>>v projectionDistance = 0,1
>>>>>>>>>v projectionAngle = 180

>>>>>>>>>GameObject Children 0 upper_arm.r

>>>>>>>>>> transform = p: (0.0, 0.2, 0.0) r: (62.1, 353.3, 205.4) s: (1.0, 1.0, 1.0)
>>>>>>>>>> UnityEngine.Rigidbody
>>>>>>>>>>v velocity = (0.0, 0.0, 0.0)
>>>>>>>>>>v angularVelocity = (0.0, 0.0, 0.0)
>>>>>>>>>>v drag = 0
>>>>>>>>>>v angularDrag = 0,05
>>>>>>>>>>v mass = 1
>>>>>>>>>>v useGravity = True
>>>>>>>>>>v maxDepenetrationVelocity = 1E+32
>>>>>>>>>>v isKinematic = True
>>>>>>>>>>v freezeRotation = False
>>>>>>>>>>v constraints = None
>>>>>>>>>>v collisionDetectionMode = Discrete
>>>>>>>>>>v centerOfMass = (0.0, 0.0, 0.0)
>>>>>>>>>>v worldCenterOfMass = (0.0, 0.0, 0.0)
>>>>>>>>>>v inertiaTensorRotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>>>>v inertiaTensor = (1.0, 1.0, 1.0)
>>>>>>>>>>v detectCollisions = True
>>>>>>>>>>v position = (0.0, 0.0, 0.0)
>>>>>>>>>>v rotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>>>>v interpolation = Interpolate
>>>>>>>>>>v solverIterations = 6
>>>>>>>>>>v sleepThreshold = 0,005
>>>>>>>>>>v maxAngularVelocity = 7
>>>>>>>>>>v solverVelocityIterations = 1
>>>>>>>>>>v sleepVelocity = 0
>>>>>>>>>>v sleepAngularVelocity = 0
>>>>>>>>>>v useConeFriction = False
>>>>>>>>>>v solverIterationCount = 6
>>>>>>>>>>v solverVelocityIterationCount = 1

>>>>>>>>>> UnityEngine.CapsuleCollider
>>>>>>>>>>v center = (0.0, 0.2, 0.0)
>>>>>>>>>>v radius = 0,07
>>>>>>>>>>v height = 0,33
>>>>>>>>>>v direction = 1

>>>>>>>>>> UnityEngine.CharacterJoint
>>>>>>>>>>v targetRotation = (0.0, 0.0, 0.0, 0.0)
>>>>>>>>>>v targetAngularVelocity = (0.0, 0.0, 0.0)
>>>>>>>>>>v rotationDrive = UnityEngine.JointDrive
>>>>>>>>>>v swingAxis = (0.0, 1.0, 0.0)
>>>>>>>>>>v twistLimitSpring = UnityEngine.SoftJointLimitSpring
>>>>>>>>>>v swingLimitSpring = UnityEngine.SoftJointLimitSpring
>>>>>>>>>>v lowTwistLimit = UnityEngine.SoftJointLimit
>>>>>>>>>>v highTwistLimit = UnityEngine.SoftJointLimit
>>>>>>>>>>v swing1Limit = UnityEngine.SoftJointLimit
>>>>>>>>>>v swing2Limit = UnityEngine.SoftJointLimit
>>>>>>>>>>v enableProjection = False
>>>>>>>>>>v projectionDistance = 0,1
>>>>>>>>>>v projectionAngle = 180

>>>>>>>>>>GameObject Children 0 lower_arm.r

>>>>>>>>>>> transform = p: (0.0, 0.3, 0.0) r: (35.7, 231.8, 200.6) s: (1.0, 1.0, 1.0)
>>>>>>>>>>> UnityEngine.Rigidbody
>>>>>>>>>>>v velocity = (0.0, 0.0, 0.0)
>>>>>>>>>>>v angularVelocity = (0.0, 0.0, 0.0)
>>>>>>>>>>>v drag = 0
>>>>>>>>>>>v angularDrag = 0,05
>>>>>>>>>>>v mass = 1
>>>>>>>>>>>v useGravity = True
>>>>>>>>>>>v maxDepenetrationVelocity = 1E+32
>>>>>>>>>>>v isKinematic = True
>>>>>>>>>>>v freezeRotation = False
>>>>>>>>>>>v constraints = None
>>>>>>>>>>>v collisionDetectionMode = Discrete
>>>>>>>>>>>v centerOfMass = (0.0, 0.0, 0.0)
>>>>>>>>>>>v worldCenterOfMass = (0.0, 0.0, 0.0)
>>>>>>>>>>>v inertiaTensorRotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>>>>>v inertiaTensor = (1.0, 1.0, 1.0)
>>>>>>>>>>>v detectCollisions = True
>>>>>>>>>>>v position = (0.0, 0.0, 0.0)
>>>>>>>>>>>v rotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>>>>>v interpolation = Interpolate
>>>>>>>>>>>v solverIterations = 6
>>>>>>>>>>>v sleepThreshold = 0,005
>>>>>>>>>>>v maxAngularVelocity = 7
>>>>>>>>>>>v solverVelocityIterations = 1
>>>>>>>>>>>v sleepVelocity = 0
>>>>>>>>>>>v sleepAngularVelocity = 0
>>>>>>>>>>>v useConeFriction = False
>>>>>>>>>>>v solverIterationCount = 6
>>>>>>>>>>>v solverVelocityIterationCount = 1

>>>>>>>>>>> UnityEngine.CapsuleCollider
>>>>>>>>>>>v center = (0.0, 0.2, 0.0)
>>>>>>>>>>>v radius = 0,07
>>>>>>>>>>>v height = 0,24
>>>>>>>>>>>v direction = 1

>>>>>>>>>>> UnityEngine.CharacterJoint
>>>>>>>>>>>v targetRotation = (0.0, 0.0, 0.0, 0.0)
>>>>>>>>>>>v targetAngularVelocity = (0.0, 0.0, 0.0)
>>>>>>>>>>>v rotationDrive = UnityEngine.JointDrive
>>>>>>>>>>>v swingAxis = (0.0, 1.0, 0.0)
>>>>>>>>>>>v twistLimitSpring = UnityEngine.SoftJointLimitSpring
>>>>>>>>>>>v swingLimitSpring = UnityEngine.SoftJointLimitSpring
>>>>>>>>>>>v lowTwistLimit = UnityEngine.SoftJointLimit
>>>>>>>>>>>v highTwistLimit = UnityEngine.SoftJointLimit
>>>>>>>>>>>v swing1Limit = UnityEngine.SoftJointLimit
>>>>>>>>>>>v swing2Limit = UnityEngine.SoftJointLimit
>>>>>>>>>>>v enableProjection = False
>>>>>>>>>>>v projectionDistance = 0,1
>>>>>>>>>>>v projectionAngle = 180

>>>>>>>>>>>GameObject Children 0 hand.r

>>>>>>>>>>>> transform = p: (0.0, 0.3, 0.0) r: (350.4, 31.2, 137.1) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>> UnityEngine.Rigidbody
>>>>>>>>>>>>v velocity = (0.0, 0.0, 0.0)
>>>>>>>>>>>>v angularVelocity = (0.0, 0.0, 0.0)
>>>>>>>>>>>>v drag = 0
>>>>>>>>>>>>v angularDrag = 0,05
>>>>>>>>>>>>v mass = 1
>>>>>>>>>>>>v useGravity = True
>>>>>>>>>>>>v maxDepenetrationVelocity = 1E+32
>>>>>>>>>>>>v isKinematic = True
>>>>>>>>>>>>v freezeRotation = False
>>>>>>>>>>>>v constraints = None
>>>>>>>>>>>>v collisionDetectionMode = Discrete
>>>>>>>>>>>>v centerOfMass = (0.0, 0.0, 0.0)
>>>>>>>>>>>>v worldCenterOfMass = (0.0, 0.0, 0.0)
>>>>>>>>>>>>v inertiaTensorRotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>>>>>>v inertiaTensor = (1.0, 1.0, 1.0)
>>>>>>>>>>>>v detectCollisions = True
>>>>>>>>>>>>v position = (0.0, 0.0, 0.0)
>>>>>>>>>>>>v rotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>>>>>>v interpolation = Interpolate
>>>>>>>>>>>>v solverIterations = 6
>>>>>>>>>>>>v sleepThreshold = 0,005
>>>>>>>>>>>>v maxAngularVelocity = 7
>>>>>>>>>>>>v solverVelocityIterations = 1
>>>>>>>>>>>>v sleepVelocity = 0
>>>>>>>>>>>>v sleepAngularVelocity = 0
>>>>>>>>>>>>v useConeFriction = False
>>>>>>>>>>>>v solverIterationCount = 6
>>>>>>>>>>>>v solverVelocityIterationCount = 1

>>>>>>>>>>>> UnityEngine.CapsuleCollider
>>>>>>>>>>>>v center = (0.0, 0.1, 0.0)
>>>>>>>>>>>>v radius = 0,06
>>>>>>>>>>>>v height = 0,18
>>>>>>>>>>>>v direction = 1

>>>>>>>>>>>> UnityEngine.CharacterJoint
>>>>>>>>>>>>v targetRotation = (0.0, 0.0, 0.0, 0.0)
>>>>>>>>>>>>v targetAngularVelocity = (0.0, 0.0, 0.0)
>>>>>>>>>>>>v rotationDrive = UnityEngine.JointDrive
>>>>>>>>>>>>v swingAxis = (0.0, 1.0, 0.0)
>>>>>>>>>>>>v twistLimitSpring = UnityEngine.SoftJointLimitSpring
>>>>>>>>>>>>v swingLimitSpring = UnityEngine.SoftJointLimitSpring
>>>>>>>>>>>>v lowTwistLimit = UnityEngine.SoftJointLimit
>>>>>>>>>>>>v highTwistLimit = UnityEngine.SoftJointLimit
>>>>>>>>>>>>v swing1Limit = UnityEngine.SoftJointLimit
>>>>>>>>>>>>v swing2Limit = UnityEngine.SoftJointLimit
>>>>>>>>>>>>v enableProjection = False
>>>>>>>>>>>>v projectionDistance = 0,1
>>>>>>>>>>>>v projectionAngle = 180

>>>>>>>>>>>>GameObject Children 0 finger1.1.r

>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (310.8, 52.9, 131.2) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>GameObject Children 0 finger1.2.r

>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (359.8, 201.3, 204.8) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>GameObject Children 0 finger1.3.r

>>>>>>>>>>>>>>> transform = p: (0.0, 0.0, 0.0) r: (329.5, 187.3, 203.1) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>>GameObject Children 0 finger1.3.r_end

>>>>>>>>>>>>>>>> transform = p: (0.0, 0.0, 0.0) r: (329.5, 187.3, 203.1) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>GameObject Children 1 finger2.1.r

>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (310.7, 51.0, 132.9) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>GameObject Children 0 finger2.2.r

>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (0.3, 201.8, 202.4) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>GameObject Children 0 finger2.3.r

>>>>>>>>>>>>>>> transform = p: (0.0, 0.0, 0.0) r: (330.2, 189.9, 199.1) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>>GameObject Children 0 finger2.3.r_end

>>>>>>>>>>>>>>>> transform = p: (0.0, 0.0, 0.0) r: (330.2, 189.9, 199.1) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>GameObject Children 2 finger3.1.r

>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (312.6, 57.7, 122.7) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>GameObject Children 0 finger3.2.r

>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (0.4, 204.7, 201.4) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>GameObject Children 0 finger3.3.r

>>>>>>>>>>>>>>> transform = p: (0.0, 0.0, 0.0) r: (329.4, 195.1, 191.6) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>>GameObject Children 0 finger3.3.r_end

>>>>>>>>>>>>>>>> transform = p: (0.0, 0.0, 0.0) r: (329.4, 195.1, 191.6) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>GameObject Children 3 finger4.1.r

>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (315.9, 64.2, 119.0) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>GameObject Children 0 finger4.2.r

>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (357.6, 208.6, 204.7) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>GameObject Children 0 finger4.3.r

>>>>>>>>>>>>>>> transform = p: (0.0, 0.0, 0.0) r: (326.3, 196.9, 195.1) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>>GameObject Children 0 finger4.3.r_end

>>>>>>>>>>>>>>>> transform = p: (0.0, 0.0, 0.0) r: (326.3, 196.9, 195.1) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>GameObject Children 4 GripControl.r

>>>>>>>>>>>>> transform = p: (0.0, 0.2, 0.0) r: (37.2, 226.1, 308.9) s: (1.1, 1.1, 1.1)
>>>>>>>>>>>>>GameObject Children 0 finger1IKTarget.r

>>>>>>>>>>>>>> transform = p: (0.1, 0.0, 0.0) r: (11.0, 13.7, 149.4) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>GameObject Children 0 finger1IKTarget.r_end

>>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (11.0, 13.7, 149.4) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>GameObject Children 1 finger2IKTarget.r

>>>>>>>>>>>>>> transform = p: (0.1, 0.0, 0.0) r: (11.0, 13.7, 149.4) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>GameObject Children 0 finger2IKTarget.r_end

>>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (11.0, 13.7, 149.4) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>GameObject Children 2 finger3IKTarget.r

>>>>>>>>>>>>>> transform = p: (0.0, 0.0, 0.0) r: (11.0, 13.7, 149.4) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>GameObject Children 0 finger3IKTarget.r_end

>>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (11.0, 13.7, 149.4) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>GameObject Children 3 finger4IKTarget.r

>>>>>>>>>>>>>> transform = p: (0.0, 0.0, 0.0) r: (11.0, 13.7, 149.4) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>GameObject Children 0 finger4IKTarget.r_end

>>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (11.0, 13.7, 149.4) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>GameObject Children 4 thumbIKTarget.r

>>>>>>>>>>>>>> transform = p: (0.0, 0.0, 0.0) r: (11.0, 13.7, 149.4) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>GameObject Children 0 thumbIKTarget.r_end

>>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (11.0, 13.7, 149.4) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>GameObject Children 5 thumb.1.r

>>>>>>>>>>>>> transform = p: (0.1, 0.1, 0.0) r: (10.1, 6.6, 155.8) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>GameObject Children 0 thumb.2.r

>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (58.3, 271.1, 256.8) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>GameObject Children 0 thumb.2.r_end

>>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (58.3, 271.1, 256.8) s: (1.0, 1.0, 1.0)
>>>>>>>>GameObject Children 2 mech.base

>>>>>>>>> transform = p: (0.0, 0.0, -0.2) r: (358.9, 0.3, 360.0) s: (1.0, 1.0, 1.0)
>>>>>>>>> UnityEngine.Rigidbody
>>>>>>>>>v velocity = (0.0, 0.0, 0.0)
>>>>>>>>>v angularVelocity = (0.0, 0.0, 0.0)
>>>>>>>>>v drag = 0
>>>>>>>>>v angularDrag = 0,05
>>>>>>>>>v mass = 1
>>>>>>>>>v useGravity = True
>>>>>>>>>v maxDepenetrationVelocity = 1E+32
>>>>>>>>>v isKinematic = True
>>>>>>>>>v freezeRotation = False
>>>>>>>>>v constraints = None
>>>>>>>>>v collisionDetectionMode = Discrete
>>>>>>>>>v centerOfMass = (0.0, 0.0, 0.0)
>>>>>>>>>v worldCenterOfMass = (0.0, 0.0, 0.0)
>>>>>>>>>v inertiaTensorRotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>>>v inertiaTensor = (1.0, 1.0, 1.0)
>>>>>>>>>v detectCollisions = True
>>>>>>>>>v position = (0.0, 0.0, 0.0)
>>>>>>>>>v rotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>>>v interpolation = Interpolate
>>>>>>>>>v solverIterations = 6
>>>>>>>>>v sleepThreshold = 0,005
>>>>>>>>>v maxAngularVelocity = 7
>>>>>>>>>v solverVelocityIterations = 1
>>>>>>>>>v sleepVelocity = 0
>>>>>>>>>v sleepAngularVelocity = 0
>>>>>>>>>v useConeFriction = False
>>>>>>>>>v solverIterationCount = 6
>>>>>>>>>v solverVelocityIterationCount = 1

>>>>>>>>> UnityEngine.CapsuleCollider
>>>>>>>>>v center = (0.0, 0.1, -0.2)
>>>>>>>>>v radius = 0,14
>>>>>>>>>v height = 0,76
>>>>>>>>>v direction = 1

>>>>>>>>> UnityEngine.CharacterJoint
>>>>>>>>>v targetRotation = (0.0, 0.0, 0.0, 0.0)
>>>>>>>>>v targetAngularVelocity = (0.0, 0.0, 0.0)
>>>>>>>>>v rotationDrive = UnityEngine.JointDrive
>>>>>>>>>v swingAxis = (0.0, 1.0, 0.0)
>>>>>>>>>v twistLimitSpring = UnityEngine.SoftJointLimitSpring
>>>>>>>>>v swingLimitSpring = UnityEngine.SoftJointLimitSpring
>>>>>>>>>v lowTwistLimit = UnityEngine.SoftJointLimit
>>>>>>>>>v highTwistLimit = UnityEngine.SoftJointLimit
>>>>>>>>>v swing1Limit = UnityEngine.SoftJointLimit
>>>>>>>>>v swing2Limit = UnityEngine.SoftJointLimit
>>>>>>>>>v enableProjection = False
>>>>>>>>>v projectionDistance = 0,1
>>>>>>>>>v projectionAngle = 180

>>>>>>>>>GameObject Children 0 mech.upper_arm.l

>>>>>>>>>> transform = p: (-0.4, 0.3, 0.2) r: (31.5, 22.5, 172.8) s: (1.0, 1.0, 1.0)
>>>>>>>>>> UnityEngine.Rigidbody
>>>>>>>>>>v velocity = (0.0, 0.0, 0.0)
>>>>>>>>>>v angularVelocity = (0.0, 0.0, 0.0)
>>>>>>>>>>v drag = 0
>>>>>>>>>>v angularDrag = 0,05
>>>>>>>>>>v mass = 1
>>>>>>>>>>v useGravity = True
>>>>>>>>>>v maxDepenetrationVelocity = 1E+32
>>>>>>>>>>v isKinematic = True
>>>>>>>>>>v freezeRotation = False
>>>>>>>>>>v constraints = None
>>>>>>>>>>v collisionDetectionMode = Discrete
>>>>>>>>>>v centerOfMass = (0.0, 0.0, 0.0)
>>>>>>>>>>v worldCenterOfMass = (0.0, 0.0, 0.0)
>>>>>>>>>>v inertiaTensorRotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>>>>v inertiaTensor = (1.0, 1.0, 1.0)
>>>>>>>>>>v detectCollisions = True
>>>>>>>>>>v position = (0.0, 0.0, 0.0)
>>>>>>>>>>v rotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>>>>v interpolation = Interpolate
>>>>>>>>>>v solverIterations = 6
>>>>>>>>>>v sleepThreshold = 0,005
>>>>>>>>>>v maxAngularVelocity = 7
>>>>>>>>>>v solverVelocityIterations = 1
>>>>>>>>>>v sleepVelocity = 0
>>>>>>>>>>v sleepAngularVelocity = 0
>>>>>>>>>>v useConeFriction = False
>>>>>>>>>>v solverIterationCount = 6
>>>>>>>>>>v solverVelocityIterationCount = 1

>>>>>>>>>> UnityEngine.CapsuleCollider
>>>>>>>>>>v center = (0.0, 0.2, 0.0)
>>>>>>>>>>v radius = 0,11
>>>>>>>>>>v height = 0,32
>>>>>>>>>>v direction = 1

>>>>>>>>>> UnityEngine.CharacterJoint
>>>>>>>>>>v targetRotation = (0.0, 0.0, 0.0, 0.0)
>>>>>>>>>>v targetAngularVelocity = (0.0, 0.0, 0.0)
>>>>>>>>>>v rotationDrive = UnityEngine.JointDrive
>>>>>>>>>>v swingAxis = (0.0, 1.0, 0.0)
>>>>>>>>>>v twistLimitSpring = UnityEngine.SoftJointLimitSpring
>>>>>>>>>>v swingLimitSpring = UnityEngine.SoftJointLimitSpring
>>>>>>>>>>v lowTwistLimit = UnityEngine.SoftJointLimit
>>>>>>>>>>v highTwistLimit = UnityEngine.SoftJointLimit
>>>>>>>>>>v swing1Limit = UnityEngine.SoftJointLimit
>>>>>>>>>>v swing2Limit = UnityEngine.SoftJointLimit
>>>>>>>>>>v enableProjection = False
>>>>>>>>>>v projectionDistance = 0,1
>>>>>>>>>>v projectionAngle = 180

>>>>>>>>>>GameObject Children 0 mech.hydraulic.base.l

>>>>>>>>>>> transform = p: (0.0, 0.4, 0.2) r: (341.2, 29.0, 175.7) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>GameObject Children 0 mech.hydraulic.piston.l

>>>>>>>>>>>> transform = p: (0.0, 0.0, 0.0) r: (342.9, 28.8, 175.7) s: (0.8, 0.8, 0.8)
>>>>>>>>>>>>GameObject Children 0 mech.hydraulic.piston.l_end

>>>>>>>>>>>>> transform = p: (0.0, 0.4, 0.0) r: (342.9, 28.8, 175.7) s: (1.0, 1.0, 1.0)
>>>>>>>>>>GameObject Children 1 mech.lower_arm.l

>>>>>>>>>>> transform = p: (0.0, 0.4, 0.0) r: (3.1, 114.8, 163.3) s: (1.0, 1.0, 1.0)
>>>>>>>>>>> UnityEngine.Rigidbody
>>>>>>>>>>>v velocity = (0.0, 0.0, 0.0)
>>>>>>>>>>>v angularVelocity = (0.0, 0.0, 0.0)
>>>>>>>>>>>v drag = 0
>>>>>>>>>>>v angularDrag = 0,05
>>>>>>>>>>>v mass = 1
>>>>>>>>>>>v useGravity = True
>>>>>>>>>>>v maxDepenetrationVelocity = 1E+32
>>>>>>>>>>>v isKinematic = True
>>>>>>>>>>>v freezeRotation = False
>>>>>>>>>>>v constraints = None
>>>>>>>>>>>v collisionDetectionMode = Discrete
>>>>>>>>>>>v centerOfMass = (0.0, 0.0, 0.0)
>>>>>>>>>>>v worldCenterOfMass = (0.0, 0.0, 0.0)
>>>>>>>>>>>v inertiaTensorRotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>>>>>v inertiaTensor = (1.0, 1.0, 1.0)
>>>>>>>>>>>v detectCollisions = True
>>>>>>>>>>>v position = (0.0, 0.0, 0.0)
>>>>>>>>>>>v rotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>>>>>v interpolation = Interpolate
>>>>>>>>>>>v solverIterations = 6
>>>>>>>>>>>v sleepThreshold = 0,005
>>>>>>>>>>>v maxAngularVelocity = 7
>>>>>>>>>>>v solverVelocityIterations = 1
>>>>>>>>>>>v sleepVelocity = 0
>>>>>>>>>>>v sleepAngularVelocity = 0
>>>>>>>>>>>v useConeFriction = False
>>>>>>>>>>>v solverIterationCount = 6
>>>>>>>>>>>v solverVelocityIterationCount = 1

>>>>>>>>>>> UnityEngine.CapsuleCollider
>>>>>>>>>>>v center = (0.0, 0.3, 0.0)
>>>>>>>>>>>v radius = 0,11
>>>>>>>>>>>v height = 0,6
>>>>>>>>>>>v direction = 1

>>>>>>>>>>> UnityEngine.CharacterJoint
>>>>>>>>>>>v targetRotation = (0.0, 0.0, 0.0, 0.0)
>>>>>>>>>>>v targetAngularVelocity = (0.0, 0.0, 0.0)
>>>>>>>>>>>v rotationDrive = UnityEngine.JointDrive
>>>>>>>>>>>v swingAxis = (0.0, 1.0, 0.0)
>>>>>>>>>>>v twistLimitSpring = UnityEngine.SoftJointLimitSpring
>>>>>>>>>>>v swingLimitSpring = UnityEngine.SoftJointLimitSpring
>>>>>>>>>>>v lowTwistLimit = UnityEngine.SoftJointLimit
>>>>>>>>>>>v highTwistLimit = UnityEngine.SoftJointLimit
>>>>>>>>>>>v swing1Limit = UnityEngine.SoftJointLimit
>>>>>>>>>>>v swing2Limit = UnityEngine.SoftJointLimit
>>>>>>>>>>>v enableProjection = False
>>>>>>>>>>>v projectionDistance = 0,1
>>>>>>>>>>>v projectionAngle = 180

>>>>>>>>>>>GameObject Children 0 mech.hand.l

>>>>>>>>>>>> transform = p: (0.0, 0.6, 0.0) r: (353.9, 296.2, 193.5) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>> UnityEngine.Rigidbody
>>>>>>>>>>>>v velocity = (0.0, 0.0, 0.0)
>>>>>>>>>>>>v angularVelocity = (0.0, 0.0, 0.0)
>>>>>>>>>>>>v drag = 0
>>>>>>>>>>>>v angularDrag = 0,05
>>>>>>>>>>>>v mass = 1
>>>>>>>>>>>>v useGravity = True
>>>>>>>>>>>>v maxDepenetrationVelocity = 1E+32
>>>>>>>>>>>>v isKinematic = True
>>>>>>>>>>>>v freezeRotation = False
>>>>>>>>>>>>v constraints = None
>>>>>>>>>>>>v collisionDetectionMode = Discrete
>>>>>>>>>>>>v centerOfMass = (0.0, 0.0, 0.0)
>>>>>>>>>>>>v worldCenterOfMass = (0.0, 0.0, 0.0)
>>>>>>>>>>>>v inertiaTensorRotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>>>>>>v inertiaTensor = (1.0, 1.0, 1.0)
>>>>>>>>>>>>v detectCollisions = True
>>>>>>>>>>>>v position = (0.0, 0.0, 0.0)
>>>>>>>>>>>>v rotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>>>>>>v interpolation = Interpolate
>>>>>>>>>>>>v solverIterations = 6
>>>>>>>>>>>>v sleepThreshold = 0,005
>>>>>>>>>>>>v maxAngularVelocity = 7
>>>>>>>>>>>>v solverVelocityIterations = 1
>>>>>>>>>>>>v sleepVelocity = 0
>>>>>>>>>>>>v sleepAngularVelocity = 0
>>>>>>>>>>>>v useConeFriction = False
>>>>>>>>>>>>v solverIterationCount = 6
>>>>>>>>>>>>v solverVelocityIterationCount = 1

>>>>>>>>>>>> UnityEngine.CapsuleCollider
>>>>>>>>>>>>v center = (0.0, 0.3, 0.0)
>>>>>>>>>>>>v radius = 0,08
>>>>>>>>>>>>v height = 0,33
>>>>>>>>>>>>v direction = 1

>>>>>>>>>>>> UnityEngine.CharacterJoint
>>>>>>>>>>>>v targetRotation = (0.0, 0.0, 0.0, 0.0)
>>>>>>>>>>>>v targetAngularVelocity = (0.0, 0.0, 0.0)
>>>>>>>>>>>>v rotationDrive = UnityEngine.JointDrive
>>>>>>>>>>>>v swingAxis = (0.0, 1.0, 0.0)
>>>>>>>>>>>>v twistLimitSpring = UnityEngine.SoftJointLimitSpring
>>>>>>>>>>>>v swingLimitSpring = UnityEngine.SoftJointLimitSpring
>>>>>>>>>>>>v lowTwistLimit = UnityEngine.SoftJointLimit
>>>>>>>>>>>>v highTwistLimit = UnityEngine.SoftJointLimit
>>>>>>>>>>>>v swing1Limit = UnityEngine.SoftJointLimit
>>>>>>>>>>>>v swing2Limit = UnityEngine.SoftJointLimit
>>>>>>>>>>>>v enableProjection = False
>>>>>>>>>>>>v projectionDistance = 0,1
>>>>>>>>>>>>v projectionAngle = 180

>>>>>>>>>>>>GameObject Children 0 mech.hand.end.l

>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (1.5, 272.5, 193.2) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>GameObject Children 0 mech.finger1.1.l

>>>>>>>>>>>>>> transform = p: (-0.1, 0.2, 0.0) r: (333.9, 299.5, 191.0) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>GameObject Children 0 mech.finger1.2.l

>>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (346.7, 121.4, 169.3) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>>GameObject Children 0 mech.finger1.3.l

>>>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (291.5, 274.9, 27.5) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>>>GameObject Children 0 mech.finger1.3.l_end

>>>>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (291.5, 274.9, 27.5) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>GameObject Children 1 mech.finger2.1.l

>>>>>>>>>>>>>> transform = p: (0.0, 0.2, 0.1) r: (334.7, 298.4, 191.0) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>GameObject Children 0 mech.finger2.2.l

>>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (345.9, 121.7, 160.5) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>>GameObject Children 0 mech.finger2.3.l

>>>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (300.3, 250.4, 44.5) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>>>GameObject Children 0 mech.finger2.3.l_end

>>>>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (300.3, 250.4, 44.5) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>GameObject Children 2 mech.finger3.1.l

>>>>>>>>>>>>>> transform = p: (0.0, 0.2, 0.1) r: (336.8, 296.8, 191.2) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>GameObject Children 0 mech.finger3.2.l

>>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (347.1, 120.0, 153.0) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>>GameObject Children 0 mech.finger3.3.l

>>>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (308.5, 232.7, 54.5) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>>>GameObject Children 0 mech.finger3.3.l_end

>>>>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (308.5, 232.7, 54.5) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>GameObject Children 3 mech.GripControl.l

>>>>>>>>>>>>>> transform = p: (0.0, 0.3, 0.0) r: (47.8, 104.2, 71.1) s: (0.8, 0.8, 0.8)
>>>>>>>>>>>>>>GameObject Children 0 mech.finger1IKTarget.l

>>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (7.3, 300.0, 192.7) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>>GameObject Children 0 mech.finger1IKTarget.l_end

>>>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (7.3, 300.0, 192.7) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>GameObject Children 1 mech.finger2IKTarget.l

>>>>>>>>>>>>>>> transform = p: (0.0, 0.0, 0.0) r: (7.3, 300.0, 192.7) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>>GameObject Children 0 mech.finger2IKTarget.l_end

>>>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (7.3, 300.0, 192.7) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>GameObject Children 2 mech.finger3IKTarget.l

>>>>>>>>>>>>>>> transform = p: (0.0, -0.1, 0.0) r: (7.3, 300.0, 192.7) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>>GameObject Children 0 mech.finger3IKTarget.l_end

>>>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (7.3, 300.0, 192.7) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>GameObject Children 3 mech.thumbIKTarget.l

>>>>>>>>>>>>>>> transform = p: (-0.1, 0.1, 0.1) r: (347.9, 295.7, 192.8) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>>GameObject Children 0 mech.thumbIKTarget.l_end

>>>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (347.9, 295.7, 192.8) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>GameObject Children 4 mech.thumb.1.l

>>>>>>>>>>>>>> transform = p: (0.0, 0.2, -0.1) r: (357.9, 313.6, 184.6) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>GameObject Children 0 mech.thumb.2.l

>>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (58.1, 124.2, 183.8) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>>GameObject Children 0 mech.thumb.2.l_end

>>>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (58.1, 124.2, 183.8) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>GameObject Children 1 MuzzleLeft

>>>>>>>>>>>>> transform = p: (0.0, 0.0, 0.0) r: (75.2, 2.6, 245.6) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>GameObject Children 1 mech.handle.l

>>>>>>>>>>>> transform = p: (0.0, 0.3, 0.1) r: (41.3, 212.8, 10.8) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>GameObject Children 0 mech.handle.l_end

>>>>>>>>>>>>> transform = p: (0.0, 0.2, 0.0) r: (41.3, 212.8, 10.8) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>GameObject Children 2 mech.hydraulictarget.l

>>>>>>>>>>>> transform = p: (0.1, 0.5, 0.0) r: (308.6, 201.5, 185.9) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>GameObject Children 0 mech.hydraulictarget.l_end

>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (308.6, 201.5, 185.9) s: (1.0, 1.0, 1.0)
>>>>>>>>>GameObject Children 1 mech.upper_arm.r

>>>>>>>>>> transform = p: (0.4, 0.3, 0.2) r: (23.2, 336.3, 187.2) s: (1.0, 1.0, 1.0)
>>>>>>>>>> UnityEngine.Rigidbody
>>>>>>>>>>v velocity = (0.0, 0.0, 0.0)
>>>>>>>>>>v angularVelocity = (0.0, 0.0, 0.0)
>>>>>>>>>>v drag = 0
>>>>>>>>>>v angularDrag = 0,05
>>>>>>>>>>v mass = 1
>>>>>>>>>>v useGravity = True
>>>>>>>>>>v maxDepenetrationVelocity = 1E+32
>>>>>>>>>>v isKinematic = True
>>>>>>>>>>v freezeRotation = False
>>>>>>>>>>v constraints = None
>>>>>>>>>>v collisionDetectionMode = Discrete
>>>>>>>>>>v centerOfMass = (0.0, 0.0, 0.0)
>>>>>>>>>>v worldCenterOfMass = (0.0, 0.0, 0.0)
>>>>>>>>>>v inertiaTensorRotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>>>>v inertiaTensor = (1.0, 1.0, 1.0)
>>>>>>>>>>v detectCollisions = True
>>>>>>>>>>v position = (0.0, 0.0, 0.0)
>>>>>>>>>>v rotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>>>>v interpolation = Interpolate
>>>>>>>>>>v solverIterations = 6
>>>>>>>>>>v sleepThreshold = 0,005
>>>>>>>>>>v maxAngularVelocity = 7
>>>>>>>>>>v solverVelocityIterations = 1
>>>>>>>>>>v sleepVelocity = 0
>>>>>>>>>>v sleepAngularVelocity = 0
>>>>>>>>>>v useConeFriction = False
>>>>>>>>>>v solverIterationCount = 6
>>>>>>>>>>v solverVelocityIterationCount = 1

>>>>>>>>>> UnityEngine.CapsuleCollider
>>>>>>>>>>v center = (0.0, 0.2, 0.0)
>>>>>>>>>>v radius = 0,11
>>>>>>>>>>v height = 0,32
>>>>>>>>>>v direction = 1

>>>>>>>>>> UnityEngine.CharacterJoint
>>>>>>>>>>v targetRotation = (0.0, 0.0, 0.0, 0.0)
>>>>>>>>>>v targetAngularVelocity = (0.0, 0.0, 0.0)
>>>>>>>>>>v rotationDrive = UnityEngine.JointDrive
>>>>>>>>>>v swingAxis = (0.0, 1.0, 0.0)
>>>>>>>>>>v twistLimitSpring = UnityEngine.SoftJointLimitSpring
>>>>>>>>>>v swingLimitSpring = UnityEngine.SoftJointLimitSpring
>>>>>>>>>>v lowTwistLimit = UnityEngine.SoftJointLimit
>>>>>>>>>>v highTwistLimit = UnityEngine.SoftJointLimit
>>>>>>>>>>v swing1Limit = UnityEngine.SoftJointLimit
>>>>>>>>>>v swing2Limit = UnityEngine.SoftJointLimit
>>>>>>>>>>v enableProjection = False
>>>>>>>>>>v projectionDistance = 0,1
>>>>>>>>>>v projectionAngle = 180

>>>>>>>>>>GameObject Children 0 mech.hydraulic.base.r

>>>>>>>>>>> transform = p: (0.0, 0.4, 0.2) r: (352.3, 331.3, 185.3) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>GameObject Children 0 mech.hydraulic.piston.r

>>>>>>>>>>>> transform = p: (0.0, 0.0, 0.0) r: (354.1, 331.5, 185.3) s: (0.9, 0.9, 0.9)
>>>>>>>>>>>>GameObject Children 0 mech.hydraulic.piston.r_end

>>>>>>>>>>>>> transform = p: (0.0, 0.4, 0.0) r: (354.1, 331.5, 185.3) s: (1.0, 1.0, 1.0)
>>>>>>>>>>GameObject Children 1 mech.lower_arm.r

>>>>>>>>>>> transform = p: (0.0, 0.4, 0.0) r: (4.4, 244.9, 191.0) s: (1.0, 1.0, 1.0)
>>>>>>>>>>> UnityEngine.Rigidbody
>>>>>>>>>>>v velocity = (0.0, 0.0, 0.0)
>>>>>>>>>>>v angularVelocity = (0.0, 0.0, 0.0)
>>>>>>>>>>>v drag = 0
>>>>>>>>>>>v angularDrag = 0,05
>>>>>>>>>>>v mass = 1
>>>>>>>>>>>v useGravity = True
>>>>>>>>>>>v maxDepenetrationVelocity = 1E+32
>>>>>>>>>>>v isKinematic = True
>>>>>>>>>>>v freezeRotation = False
>>>>>>>>>>>v constraints = None
>>>>>>>>>>>v collisionDetectionMode = Discrete
>>>>>>>>>>>v centerOfMass = (0.0, 0.0, 0.0)
>>>>>>>>>>>v worldCenterOfMass = (0.0, 0.0, 0.0)
>>>>>>>>>>>v inertiaTensorRotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>>>>>v inertiaTensor = (1.0, 1.0, 1.0)
>>>>>>>>>>>v detectCollisions = True
>>>>>>>>>>>v position = (0.0, 0.0, 0.0)
>>>>>>>>>>>v rotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>>>>>v interpolation = Interpolate
>>>>>>>>>>>v solverIterations = 6
>>>>>>>>>>>v sleepThreshold = 0,005
>>>>>>>>>>>v maxAngularVelocity = 7
>>>>>>>>>>>v solverVelocityIterations = 1
>>>>>>>>>>>v sleepVelocity = 0
>>>>>>>>>>>v sleepAngularVelocity = 0
>>>>>>>>>>>v useConeFriction = False
>>>>>>>>>>>v solverIterationCount = 6
>>>>>>>>>>>v solverVelocityIterationCount = 1

>>>>>>>>>>> UnityEngine.CapsuleCollider
>>>>>>>>>>>v center = (0.0, 0.3, 0.0)
>>>>>>>>>>>v radius = 0,11
>>>>>>>>>>>v height = 0,6
>>>>>>>>>>>v direction = 1

>>>>>>>>>>> UnityEngine.CharacterJoint
>>>>>>>>>>>v targetRotation = (0.0, 0.0, 0.0, 0.0)
>>>>>>>>>>>v targetAngularVelocity = (0.0, 0.0, 0.0)
>>>>>>>>>>>v rotationDrive = UnityEngine.JointDrive
>>>>>>>>>>>v swingAxis = (0.0, 1.0, 0.0)
>>>>>>>>>>>v twistLimitSpring = UnityEngine.SoftJointLimitSpring
>>>>>>>>>>>v swingLimitSpring = UnityEngine.SoftJointLimitSpring
>>>>>>>>>>>v lowTwistLimit = UnityEngine.SoftJointLimit
>>>>>>>>>>>v highTwistLimit = UnityEngine.SoftJointLimit
>>>>>>>>>>>v swing1Limit = UnityEngine.SoftJointLimit
>>>>>>>>>>>v swing2Limit = UnityEngine.SoftJointLimit
>>>>>>>>>>>v enableProjection = False
>>>>>>>>>>>v projectionDistance = 0,1
>>>>>>>>>>>v projectionAngle = 180

>>>>>>>>>>>GameObject Children 0 mech.hand.r

>>>>>>>>>>>> transform = p: (0.0, 0.6, 0.0) r: (352.8, 63.2, 127.7) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>> UnityEngine.Rigidbody
>>>>>>>>>>>>v velocity = (0.0, 0.0, 0.0)
>>>>>>>>>>>>v angularVelocity = (0.0, 0.0, 0.0)
>>>>>>>>>>>>v drag = 0
>>>>>>>>>>>>v angularDrag = 0,05
>>>>>>>>>>>>v mass = 1
>>>>>>>>>>>>v useGravity = True
>>>>>>>>>>>>v maxDepenetrationVelocity = 1E+32
>>>>>>>>>>>>v isKinematic = True
>>>>>>>>>>>>v freezeRotation = False
>>>>>>>>>>>>v constraints = None
>>>>>>>>>>>>v collisionDetectionMode = Discrete
>>>>>>>>>>>>v centerOfMass = (0.0, 0.0, 0.0)
>>>>>>>>>>>>v worldCenterOfMass = (0.0, 0.0, 0.0)
>>>>>>>>>>>>v inertiaTensorRotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>>>>>>v inertiaTensor = (1.0, 1.0, 1.0)
>>>>>>>>>>>>v detectCollisions = True
>>>>>>>>>>>>v position = (0.0, 0.0, 0.0)
>>>>>>>>>>>>v rotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>>>>>>v interpolation = Interpolate
>>>>>>>>>>>>v solverIterations = 6
>>>>>>>>>>>>v sleepThreshold = 0,005
>>>>>>>>>>>>v maxAngularVelocity = 7
>>>>>>>>>>>>v solverVelocityIterations = 1
>>>>>>>>>>>>v sleepVelocity = 0
>>>>>>>>>>>>v sleepAngularVelocity = 0
>>>>>>>>>>>>v useConeFriction = False
>>>>>>>>>>>>v solverIterationCount = 6
>>>>>>>>>>>>v solverVelocityIterationCount = 1

>>>>>>>>>>>> UnityEngine.CapsuleCollider
>>>>>>>>>>>>v center = (0.0, 0.3, 0.0)
>>>>>>>>>>>>v radius = 0,08
>>>>>>>>>>>>v height = 0,33
>>>>>>>>>>>>v direction = 1

>>>>>>>>>>>> UnityEngine.CharacterJoint
>>>>>>>>>>>>v targetRotation = (0.0, 0.0, 0.0, 0.0)
>>>>>>>>>>>>v targetAngularVelocity = (0.0, 0.0, 0.0)
>>>>>>>>>>>>v rotationDrive = UnityEngine.JointDrive
>>>>>>>>>>>>v swingAxis = (0.0, 1.0, 0.0)
>>>>>>>>>>>>v twistLimitSpring = UnityEngine.SoftJointLimitSpring
>>>>>>>>>>>>v swingLimitSpring = UnityEngine.SoftJointLimitSpring
>>>>>>>>>>>>v lowTwistLimit = UnityEngine.SoftJointLimit
>>>>>>>>>>>>v highTwistLimit = UnityEngine.SoftJointLimit
>>>>>>>>>>>>v swing1Limit = UnityEngine.SoftJointLimit
>>>>>>>>>>>>v swing2Limit = UnityEngine.SoftJointLimit
>>>>>>>>>>>>v enableProjection = False
>>>>>>>>>>>>v projectionDistance = 0,1
>>>>>>>>>>>>v projectionAngle = 180

>>>>>>>>>>>>GameObject Children 0 mech.hand.end.r

>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (13.3, 77.3, 129.8) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>GameObject Children 0 mech.finger1.1.r

>>>>>>>>>>>>>> transform = p: (0.1, 0.2, 0.0) r: (335.8, 71.3, 126.7) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>GameObject Children 0 mech.finger1.2.r

>>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (355.5, 227.5, 217.5) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>>GameObject Children 0 mech.finger1.3.r

>>>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (300.8, 129.9, 269.3) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>>>GameObject Children 0 mech.finger1.3.r_end

>>>>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (300.8, 129.9, 269.3) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>GameObject Children 1 mech.finger2.1.r

>>>>>>>>>>>>>> transform = p: (0.0, 0.2, 0.1) r: (336.2, 72.6, 126.6) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>GameObject Children 0 mech.finger2.2.r

>>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (354.7, 226.5, 226.0) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>>GameObject Children 0 mech.finger2.3.r

>>>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (314.1, 126.3, 277.4) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>>>GameObject Children 0 mech.finger2.3.r_end

>>>>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (314.1, 126.3, 277.4) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>GameObject Children 2 mech.finger3.1.r

>>>>>>>>>>>>>> transform = p: (0.0, 0.2, 0.1) r: (338.1, 73.4, 126.7) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>GameObject Children 0 mech.finger3.2.r

>>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (354.7, 228.3, 233.8) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>>GameObject Children 0 mech.finger3.3.r

>>>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (326.1, 129.4, 280.4) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>>>GameObject Children 0 mech.finger3.3.r_end

>>>>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (326.1, 129.4, 280.4) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>GameObject Children 3 mech.GripControl.r

>>>>>>>>>>>>>> transform = p: (0.0, 0.3, 0.0) r: (31.4, 281.3, 335.1) s: (0.8, 0.8, 0.8)
>>>>>>>>>>>>>>GameObject Children 0 mech.finger1IKTarget.r

>>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (0.9, 51.8, 129.3) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>>GameObject Children 0 mech.finger1IKTarget.r_end

>>>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (0.9, 51.8, 129.3) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>GameObject Children 1 mech.finger2IKTarget.r

>>>>>>>>>>>>>>> transform = p: (0.0, 0.0, 0.0) r: (0.9, 51.8, 129.3) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>>GameObject Children 0 mech.finger2IKTarget.r_end

>>>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (0.9, 51.8, 129.3) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>GameObject Children 2 mech.finger3IKTarget.r

>>>>>>>>>>>>>>> transform = p: (0.0, -0.1, 0.0) r: (0.9, 51.8, 129.3) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>>GameObject Children 0 mech.finger3IKTarget.r_end

>>>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (0.9, 51.8, 129.3) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>GameObject Children 3 mech.thumbIKTarget.r

>>>>>>>>>>>>>>> transform = p: (0.0, -0.1, -0.1) r: (348.4, 67.5, 127.8) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>>GameObject Children 0 mech.thumbIKTarget.r_end

>>>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (348.4, 67.5, 127.8) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>GameObject Children 4 mech.thumb.1.r

>>>>>>>>>>>>>> transform = p: (0.0, 0.2, -0.1) r: (334.9, 63.2, 182.7) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>GameObject Children 0 mech.thumb.2.r

>>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (74.3, 161.6, 54.4) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>>>>GameObject Children 0 mech.thumb.2.r_end

>>>>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (74.3, 161.6, 54.4) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>GameObject Children 1 mech.handle.r

>>>>>>>>>>>> transform = p: (0.0, 0.3, 0.1) r: (35.5, 146.9, 348.5) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>GameObject Children 0 mech.handle.r_end

>>>>>>>>>>>>> transform = p: (0.0, 0.2, 0.0) r: (35.5, 146.9, 348.5) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>GameObject Children 2 mech.hydraulictarget.r

>>>>>>>>>>>> transform = p: (-0.1, 0.5, 0.0) r: (303.1, 161.0, 171.1) s: (1.0, 1.0, 1.0)
>>>>>>>>>>>>GameObject Children 0 mech.hydraulictarget.r_end

>>>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (303.1, 161.0, 171.1) s: (1.0, 1.0, 1.0)
>>>>>>>>GameObject Children 3 neck

>>>>>>>>> transform = p: (0.0, 0.3, 0.0) r: (15.7, 179.9, 0.0) s: (1.0, 1.0, 1.0)
>>>>>>>>> UnityEngine.Rigidbody
>>>>>>>>>v velocity = (0.0, 0.0, 0.0)
>>>>>>>>>v angularVelocity = (0.0, 0.0, 0.0)
>>>>>>>>>v drag = 0
>>>>>>>>>v angularDrag = 0,05
>>>>>>>>>v mass = 1
>>>>>>>>>v useGravity = True
>>>>>>>>>v maxDepenetrationVelocity = 1E+32
>>>>>>>>>v isKinematic = True
>>>>>>>>>v freezeRotation = False
>>>>>>>>>v constraints = None
>>>>>>>>>v collisionDetectionMode = Discrete
>>>>>>>>>v centerOfMass = (0.0, 0.0, 0.0)
>>>>>>>>>v worldCenterOfMass = (0.0, 0.0, 0.0)
>>>>>>>>>v inertiaTensorRotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>>>v inertiaTensor = (1.0, 1.0, 1.0)
>>>>>>>>>v detectCollisions = True
>>>>>>>>>v position = (0.0, 0.0, 0.0)
>>>>>>>>>v rotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>>>v interpolation = Interpolate
>>>>>>>>>v solverIterations = 6
>>>>>>>>>v sleepThreshold = 0,005
>>>>>>>>>v maxAngularVelocity = 7
>>>>>>>>>v solverVelocityIterations = 1
>>>>>>>>>v sleepVelocity = 0
>>>>>>>>>v sleepAngularVelocity = 0
>>>>>>>>>v useConeFriction = False
>>>>>>>>>v solverIterationCount = 6
>>>>>>>>>v solverVelocityIterationCount = 1

>>>>>>>>> UnityEngine.CapsuleCollider
>>>>>>>>>v center = (0.0, 0.1, 0.0)
>>>>>>>>>v radius = 0,06
>>>>>>>>>v height = 0,31
>>>>>>>>>v direction = 0

>>>>>>>>> UnityEngine.CharacterJoint
>>>>>>>>>v targetRotation = (0.0, 0.0, 0.0, 0.0)
>>>>>>>>>v targetAngularVelocity = (0.0, 0.0, 0.0)
>>>>>>>>>v rotationDrive = UnityEngine.JointDrive
>>>>>>>>>v swingAxis = (0.0, 1.0, 0.0)
>>>>>>>>>v twistLimitSpring = UnityEngine.SoftJointLimitSpring
>>>>>>>>>v swingLimitSpring = UnityEngine.SoftJointLimitSpring
>>>>>>>>>v lowTwistLimit = UnityEngine.SoftJointLimit
>>>>>>>>>v highTwistLimit = UnityEngine.SoftJointLimit
>>>>>>>>>v swing1Limit = UnityEngine.SoftJointLimit
>>>>>>>>>v swing2Limit = UnityEngine.SoftJointLimit
>>>>>>>>>v enableProjection = False
>>>>>>>>>v projectionDistance = 0,1
>>>>>>>>>v projectionAngle = 180

>>>>>>>>>GameObject Children 0 head

>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (0.2, 359.9, 359.7) s: (1.0, 1.0, 1.0)
>>>>>>>>>> UnityEngine.Rigidbody
>>>>>>>>>>v velocity = (0.0, 0.0, 0.0)
>>>>>>>>>>v angularVelocity = (0.0, 0.0, 0.0)
>>>>>>>>>>v drag = 0
>>>>>>>>>>v angularDrag = 0,05
>>>>>>>>>>v mass = 1
>>>>>>>>>>v useGravity = True
>>>>>>>>>>v maxDepenetrationVelocity = 1E+32
>>>>>>>>>>v isKinematic = True
>>>>>>>>>>v freezeRotation = False
>>>>>>>>>>v constraints = None
>>>>>>>>>>v collisionDetectionMode = Discrete
>>>>>>>>>>v centerOfMass = (0.0, 0.0, 0.0)
>>>>>>>>>>v worldCenterOfMass = (0.0, 0.0, 0.0)
>>>>>>>>>>v inertiaTensorRotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>>>>v inertiaTensor = (1.0, 1.0, 1.0)
>>>>>>>>>>v detectCollisions = True
>>>>>>>>>>v position = (0.0, 0.0, 0.0)
>>>>>>>>>>v rotation = (0.0, 0.0, 0.0, 1.0)
>>>>>>>>>>v interpolation = Interpolate
>>>>>>>>>>v solverIterations = 6
>>>>>>>>>>v sleepThreshold = 0,005
>>>>>>>>>>v maxAngularVelocity = 7
>>>>>>>>>>v solverVelocityIterations = 1
>>>>>>>>>>v sleepVelocity = 0
>>>>>>>>>>v sleepAngularVelocity = 0
>>>>>>>>>>v useConeFriction = False
>>>>>>>>>>v solverIterationCount = 6
>>>>>>>>>>v solverVelocityIterationCount = 1

>>>>>>>>>> UnityEngine.CapsuleCollider
>>>>>>>>>>v center = (0.0, 0.1, 0.0)
>>>>>>>>>>v radius = 0,13
>>>>>>>>>>v height = 0,15
>>>>>>>>>>v direction = 1

>>>>>>>>>> UnityEngine.CharacterJoint
>>>>>>>>>>v targetRotation = (0.0, 0.0, 0.0, 0.0)
>>>>>>>>>>v targetAngularVelocity = (0.0, 0.0, 0.0)
>>>>>>>>>>v rotationDrive = UnityEngine.JointDrive
>>>>>>>>>>v swingAxis = (0.0, 1.0, 0.0)
>>>>>>>>>>v twistLimitSpring = UnityEngine.SoftJointLimitSpring
>>>>>>>>>>v swingLimitSpring = UnityEngine.SoftJointLimitSpring
>>>>>>>>>>v lowTwistLimit = UnityEngine.SoftJointLimit
>>>>>>>>>>v highTwistLimit = UnityEngine.SoftJointLimit
>>>>>>>>>>v swing1Limit = UnityEngine.SoftJointLimit
>>>>>>>>>>v swing2Limit = UnityEngine.SoftJointLimit
>>>>>>>>>>v enableProjection = False
>>>>>>>>>>v projectionDistance = 0,1
>>>>>>>>>>v projectionAngle = 180

>>>>>>>>>>GameObject Children 0 head_end

>>>>>>>>>>> transform = p: (0.0, 0.2, 0.0) r: (0.2, 359.9, 359.7) s: (1.0, 1.0, 1.0)
>>>>>>>>>>GameObject Children 1 HeadCenter

>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (0.2, 359.9, 359.7) s: (1.0, 1.0, 1.0)
>>>>>>>>>>GameObject Children 2 Hurtbox

>>>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (0.2, 359.9, 359.7) s: (1.0, 1.0, 1.0)
>>>>>>>>>>> UnityEngine.SphereCollider
>>>>>>>>>>>v center = (0.0, 0.0, 0.0)
>>>>>>>>>>>v radius = 0,18

>>>>>>>>>>> RoR2.HurtBox
>>>>>>>>>>>v healthComponent = LoaderBody (RoR2.HealthComponent)
>>>>>>>>>>>v isBullseye = False
>>>>>>>>>>>v isSniperTarget = True
>>>>>>>>>>>v damageModifier = Normal
>>>>>>>>>>>v <teamIndex>k__BackingField = None
>>>>>>>>>>>v hurtBoxGroup = mdlLoader (RoR2.HurtBoxGroup)
>>>>>>>>>>>v indexInGroup = 0
>>>>>>>>>>>v <collider>k__BackingField = 
>>>>>>>>>>>v <volume>k__BackingField = 0
>>>>>>>>>>>v isInBullseyeList = False
>>>>>>>>>>>v isInSniperTargetList = False
>>>>>>>>>>>v bullseyesList = System.Collections.Generic.List`1[RoR2.HurtBox]
>>>>>>>>>>>v readOnlyBullseyesList = System.Collections.ObjectModel.ReadOnlyCollection`1[RoR2.HurtBox]
>>>>>>>>>>>v sniperTargetsList = System.Collections.Generic.List`1[RoR2.HurtBox]
>>>>>>>>>>>v sniperTargetRadius = 1
>>>>>>>>>>>v sniperTargetRadiusSqr = 1
>>>>>>>>>>>v teamIndex = None
>>>>>>>>>>>v collider = 
>>>>>>>>>>>v volume = 0
>>>>>>>>>>>v readOnlySniperTargetsList = System.Collections.Generic.List`1[RoR2.HurtBox]

>>>>>>GameObject Children 6 SwingLeft

>>>>>>> transform = p: (0.0, 0.0, -0.1) r: (294.3, 118.6, 109.3) s: (1.0, 1.0, 1.0)
>>>>>>GameObject Children 7 SwingRight

>>>>>>> transform = p: (0.0, 0.0, -0.2) r: (60.7, 64.6, 111.5) s: (1.0, 1.0, 1.0)
>>>>>GameObject Children 1 HeelRoll.l

>>>>>> transform = p: (-0.2, 0.3, 0.0) r: (0.0, 179.9, 203.7) s: (1.0, 1.0, 1.0)
>>>>>>GameObject Children 0 IKLegPole.l

>>>>>>> transform = p: (0.0, 1.0, -0.7) r: (356.6, 346.0, 156.4) s: (1.0, 1.0, 1.0)
>>>>>>>GameObject Children 0 IKLegPole.l_end

>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (356.6, 346.0, 156.4) s: (1.0, 1.0, 1.0)
>>>>>>GameObject Children 1 ToeRoll.l

>>>>>>> transform = p: (0.0, 0.2, 0.0) r: (9.2, 355.7, 336.0) s: (1.0, 1.0, 1.0)
>>>>>>>GameObject Children 0 FootRoll.l

>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (47.7, 333.6, 325.2) s: (1.0, 1.0, 1.0)
>>>>>>>>GameObject Children 0 IKLegTarget.l

>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (359.9, 360.0, 336.3) s: (1.0, 1.0, 1.0)
>>>>>>>>>GameObject Children 0 IKLegTarget.l_end

>>>>>>>>>> transform = p: (0.0, 0.2, 0.0) r: (359.9, 360.0, 336.3) s: (1.0, 1.0, 1.0)
>>>>>>>GameObject Children 1 IKFoot.l

>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (66.3, 269.9, 270.0) s: (1.0, 1.0, 1.0)
>>>>>>>>GameObject Children 0 IKFoot.l_end

>>>>>>>>> transform = p: (0.0, 0.0, 0.0) r: (66.3, 269.9, 270.0) s: (1.0, 1.0, 1.0)
>>>>>>>GameObject Children 2 ToeControl.l

>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (359.9, 360.0, 156.3) s: (1.0, 1.0, 1.0)
>>>>>>>>GameObject Children 0 IKToe.l

>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (66.3, 270.1, 270.2) s: (1.0, 1.0, 1.0)
>>>>>>>>>GameObject Children 0 IKToe.l_end

>>>>>>>>>> transform = p: (0.0, 0.0, 0.0) r: (66.3, 270.1, 270.2) s: (1.0, 1.0, 1.0)
>>>>>GameObject Children 2 HeelRoll.r

>>>>>> transform = p: (0.3, 0.0, 0.0) r: (0.0, 179.9, 159.4) s: (1.0, 1.0, 1.0)
>>>>>>GameObject Children 0 IKLegPole.r

>>>>>>> transform = p: (0.0, 1.0, -0.7) r: (357.3, 14.0, 200.5) s: (1.0, 1.0, 1.0)
>>>>>>>GameObject Children 0 IKLegPole.r_end

>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (357.3, 14.0, 200.5) s: (1.0, 1.0, 1.0)
>>>>>>GameObject Children 1 ToeRoll.r

>>>>>>> transform = p: (0.0, 0.2, 0.0) r: (9.5, 3.7, 20.9) s: (1.0, 1.0, 1.0)
>>>>>>>GameObject Children 0 FootRoll.r

>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (49.2, 23.2, 30.6) s: (1.0, 1.0, 1.0)
>>>>>>>>GameObject Children 0 IKLegTarget.r

>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (0.1, 359.9, 20.6) s: (1.0, 1.0, 1.0)
>>>>>>>>>GameObject Children 0 IKLegTarget.r_end

>>>>>>>>>> transform = p: (0.0, 0.2, 0.0) r: (0.1, 359.9, 20.6) s: (1.0, 1.0, 1.0)
>>>>>>>GameObject Children 1 IKFoot.r

>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (69.4, 90.2, 90.2) s: (1.0, 1.0, 1.0)
>>>>>>>>GameObject Children 0 IKFoot.r_end

>>>>>>>>> transform = p: (0.0, 0.0, 0.0) r: (69.4, 90.2, 90.2) s: (1.0, 1.0, 1.0)
>>>>>>>GameObject Children 2 ToeControl.r

>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (0.0, 359.9, 200.6) s: (1.0, 1.0, 1.0)
>>>>>>>>GameObject Children 0 IKToe.r

>>>>>>>>> transform = p: (0.0, 0.1, 0.0) r: (69.4, 89.9, 90.0) s: (1.0, 1.0, 1.0)
>>>>>>>>>GameObject Children 0 IKToe.r_end

>>>>>>>>>> transform = p: (0.0, 0.0, 0.0) r: (69.4, 89.9, 90.0) s: (1.0, 1.0, 1.0)
>>>GameObject Children 1 LoaderMechMesh

>>>> transform = p: (0.0, 1.3, 0.0) r: (270.0, 359.9, 0.0) s: (0.5, 0.5, 0.5)
>>>> UnityEngine.SkinnedMeshRenderer
>>>>v quality = Auto
>>>>v updateWhenOffscreen = True
>>>>v forceMatrixRecalculationPerRender = False
>>>>v rootBone = ROOT (UnityEngine.Transform)
>>>>v bones = UnityEngine.Transform[]
>>>>v sharedMesh = LoaderMechMesh (UnityEngine.Mesh)
>>>>v skinnedMotionVectors = True
>>>>v localBounds = Center: (0.0, 1.5, -0.1), Extents: (0.8, 0.9, 0.5)

>>>GameObject Children 2 PilotFemaleFoldedOverJumpsuit

>>>> transform = p: (0.0, 0.0, 0.0) r: (270.0, 359.9, 0.0) s: (1.0, 1.0, 1.0)
>>>> UnityEngine.SkinnedMeshRenderer
>>>>v quality = Auto
>>>>v updateWhenOffscreen = True
>>>>v forceMatrixRecalculationPerRender = False
>>>>v rootBone = ROOT (UnityEngine.Transform)
>>>>v bones = UnityEngine.Transform[]
>>>>v sharedMesh = PilotFemaleFoldedOverJumpsuit (UnityEngine.Mesh)
>>>>v skinnedMotionVectors = True
>>>>v localBounds = Center: (0.0, 1.4, -0.4), Extents: (0.6, 0.6, 0.8)

>>>GameObject Children 3 PilotFemaleMesh

>>>> transform = p: (0.0, 0.0, 0.0) r: (270.0, 359.9, 0.0) s: (1.0, 1.0, 1.0)
>>>> UnityEngine.SkinnedMeshRenderer
>>>>v quality = Auto
>>>>v updateWhenOffscreen = True
>>>>v forceMatrixRecalculationPerRender = False
>>>>v rootBone = ROOT (UnityEngine.Transform)
>>>>v bones = UnityEngine.Transform[]
>>>>v sharedMesh = PilotFemaleMesh (UnityEngine.Mesh)
>>>>v skinnedMotionVectors = True
>>>>v localBounds = Center: (0.0, 1.2, -0.4), Extents: (0.9, 1.3, 0.7)

>>>GameObject Children 4 TempHurtbox

>>>> transform = p: (0.0, 1.1, 0.0) r: (0.0, 359.9, 0.0) s: (1.0, 1.0, 1.0)
>>>> UnityEngine.CapsuleCollider
>>>>v center = (0.0, 0.0, 0.0)
>>>>v radius = 0,5
>>>>v height = 2,1
>>>>v direction = 1

>>>> RoR2.HurtBox
>>>>v healthComponent = LoaderBody (RoR2.HealthComponent)
>>>>v isBullseye = True
>>>>v isSniperTarget = False
>>>>v damageModifier = Normal
>>>>v <teamIndex>k__BackingField = None
>>>>v hurtBoxGroup = mdlLoader (RoR2.HurtBoxGroup)
>>>>v indexInGroup = 1
>>>>v <collider>k__BackingField = 
>>>>v <volume>k__BackingField = 0
>>>>v isInBullseyeList = False
>>>>v isInSniperTargetList = False
>>>>v bullseyesList = System.Collections.Generic.List`1[RoR2.HurtBox]
>>>>v readOnlyBullseyesList = System.Collections.ObjectModel.ReadOnlyCollection`1[RoR2.HurtBox]
>>>>v sniperTargetsList = System.Collections.Generic.List`1[RoR2.HurtBox]
>>>>v sniperTargetRadius = 1
>>>>v sniperTargetRadiusSqr = 1
>>>>v teamIndex = None
>>>>v collider = 
>>>>v volume = 0
>>>>v readOnlySniperTargetsList = System.Collections.Generic.List`1[RoR2.HurtBox]

>>>GameObject Children 5 PunchHitBox

>>>> transform = p: (0.0, 1.4, 0.9) r: (0.0, 359.9, 0.0) s: (5.5, 5.5, 5.9)
>>>> RoR2.HitBox

>>>GameObject Children 6 MuzzleCenter

>>>> transform = p: (0.0, 1.5, 1.2) r: (0.0, 359.9, 0.0) s: (1.0, 1.0, 1.0)
>>>GameObject Children 7 PunchLollypopHitbox

>>>> transform = p: (0.0, 1.4, 2.2) r: (0.0, 359.9, 0.0) s: (5.6, 5.7, 6.0)
>>>> RoR2.HitBox

>>>GameObject Children 8 SprintLoopSound

>>>> transform = p: (0.0, 0.0, 0.0) r: (0.0, 359.9, 0.0) s: (1.0, 1.0, 1.0)
>>>> AkGameObj
>>>>v m_listeners = AkGameObjListenerList
>>>>v isEnvironmentAware = True
>>>>v isStaticObject = False
>>>>v m_Collider = 
>>>>v m_envData = 
>>>>v m_posData = 
>>>>v m_positionOffsetData = AkGameObjPositionOffsetData
>>>>v isRegistered = False
>>>>v m_posOffsetData = 
>>>>v AK_NUM_LISTENERS = 8
>>>>v listenerMask = 1
>>>>v IsUsingDefaultListeners = True
>>>>v ListenerList = System.Collections.Generic.List`1[AkAudioListener]

>>>> AkEvent
>>>>v actionOnEventType = AkActionOnEventType_Stop
>>>>v curveInterpolation = AkCurveInterpolation_Linear
>>>>v enableActionOnEvent = False
>>>>v data = Empty Event
>>>>v useCallbacks = False
>>>>v Callbacks = System.Collections.Generic.List`1[AkEvent+CallbackData]
>>>>v playingId = 0
>>>>v soundEmitterObject = 
>>>>v transitionDuration = 0
>>>>v EventCallbackMsg = 
>>>>v eventIdInternal = 0
>>>>v valueGuidInternal = System.Byte[]
>>>>v m_callbackDataInternal = 
>>>>v eventID = 0
>>>>v valueGuid = 
>>>>v m_callbackData = 

>>>> AkEvent
>>>>v actionOnEventType = AkActionOnEventType_Stop
>>>>v curveInterpolation = AkCurveInterpolation_Linear
>>>>v enableActionOnEvent = False
>>>>v data = Empty Event
>>>>v useCallbacks = False
>>>>v Callbacks = System.Collections.Generic.List`1[AkEvent+CallbackData]
>>>>v playingId = 0
>>>>v soundEmitterObject = 
>>>>v transitionDuration = 0
>>>>v EventCallbackMsg = 
>>>>v eventIdInternal = 0
>>>>v valueGuidInternal = System.Byte[]
>>>>v m_callbackDataInternal = 
>>>>v eventID = 0
>>>>v valueGuid = 
>>>>v m_callbackData = 

>>>> UnityEngine.Rigidbody
>>>>v velocity = (0.0, 0.0, 0.0)
>>>>v angularVelocity = (0.0, 0.0, 0.0)
>>>>v drag = 0
>>>>v angularDrag = 0,05
>>>>v mass = 1
>>>>v useGravity = False
>>>>v maxDepenetrationVelocity = 1E+32
>>>>v isKinematic = True
>>>>v freezeRotation = False
>>>>v constraints = None
>>>>v collisionDetectionMode = Discrete
>>>>v centerOfMass = (0.0, 0.0, 0.0)
>>>>v worldCenterOfMass = (0.0, 0.0, 0.0)
>>>>v inertiaTensorRotation = (0.0, 0.0, 0.0, 1.0)
>>>>v inertiaTensor = (1.0, 1.0, 1.0)
>>>>v detectCollisions = True
>>>>v position = (0.0, 0.0, 0.0)
>>>>v rotation = (0.0, 0.0, 0.0, 1.0)
>>>>v interpolation = None
>>>>v solverIterations = 6
>>>>v sleepThreshold = 0,005
>>>>v maxAngularVelocity = 7
>>>>v solverVelocityIterations = 1
>>>>v sleepVelocity = 0
>>>>v sleepAngularVelocity = 0
>>>>v useConeFriction = False
>>>>v solverIterationCount = 6
>>>>v solverVelocityIterationCount = 1

>>>GameObject Children 9 LogbookTarget

>>>> transform = p: (0.0, 1.5, 0.0) r: (0.0, 359.9, 0.0) s: (1.0, 1.0, 1.0)
>>>>GameObject Children 0 LogbookCamera

>>>>> transform = p: (-0.4, 0.2, 0.6) r: (0.0, 359.9, 0.0) s: (1.0, 1.0, 1.0)
>GameObject Children 1 CameraPivot

>> transform = p: (0.0, 1.6, 0.0) r: (0.0, 359.9, 0.0) s: (1.0, 1.0, 1.0)
>GameObject Children 2 AimOrigin

>> transform = p: (0.0, 0.9, 0.0) r: (0.0, 359.9, 0.0) s: (1.0, 1.0, 1.0)